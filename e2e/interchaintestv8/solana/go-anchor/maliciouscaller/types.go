// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package malicious_caller

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
)

// Account metadata for CPI calls (serializable version of `AccountMeta`)
type MaliciousCallerCpiAccountMeta struct {
	IsSigner   bool `json:"isSigner"`
	IsWritable bool `json:"isWritable"`
}

func (obj MaliciousCallerCpiAccountMeta) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `IsSigner`:
	err = encoder.Encode(obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Serialize `IsWritable`:
	err = encoder.Encode(obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj MaliciousCallerCpiAccountMeta) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MaliciousCallerCpiAccountMeta: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MaliciousCallerCpiAccountMeta) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `IsSigner`:
	err = decoder.Decode(&obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Deserialize `IsWritable`:
	err = decoder.Decode(&obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj *MaliciousCallerCpiAccountMeta) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MaliciousCallerCpiAccountMeta: %w", err)
	}
	return nil
}

func UnmarshalMaliciousCallerCpiAccountMeta(buf []byte) (*MaliciousCallerCpiAccountMeta, error) {
	obj := new(MaliciousCallerCpiAccountMeta)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
