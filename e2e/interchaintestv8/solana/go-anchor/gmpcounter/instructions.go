// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package gmp_counter_app

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the counter app
func NewInitializeInstruction(
	// Params:
	authorityParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `authorityParam`:
		err = enc__.Encode(authorityParam)
		if err != nil {
			return nil, errors.NewField("authorityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "increment" instruction.
// Increment a user's counter (typically called by GMP program) // The user is identified by the `user_authority` signer (ICS27 `gmp_account` PDA)
func NewIncrementInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	appStateAccount solanago.PublicKey,
	userCounterAccount solanago.PublicKey,
	userAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Increment[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "user_counter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userCounterAccount, true, false))
		// Account 2 "user_authority": Read-only, Signer, Required
		// The user authority (`gmp_account` PDA for ICS27)
		// MUST be a signer to authorize operations on this user's counter
		accounts__.Append(solanago.NewAccountMeta(userAuthorityAccount, false, true))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "decrement" instruction.
// Decrement a user's counter (typically called by GMP program)
func NewDecrementInstruction(
	// Params:
	userParam solanago.PublicKey,
	amountParam uint64,

	// Accounts:
	appStateAccount solanago.PublicKey,
	userCounterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Decrement[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `userParam`:
		err = enc__.Encode(userParam)
		if err != nil {
			return nil, errors.NewField("userParam", err)
		}
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "user_counter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userCounterAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "get_counter" instruction.
// Get a user's counter value
func NewGetCounterInstruction(
	// Params:
	userParam solanago.PublicKey,

	// Accounts:
	userCounterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetCounter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `userParam`:
		err = enc__.Encode(userParam)
		if err != nil {
			return nil, errors.NewField("userParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "user_counter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(userCounterAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
