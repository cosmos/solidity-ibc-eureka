pub mod idl;

mod instruction_gen;
mod pda;
mod type_gen;
mod util;

use std::collections::BTreeSet;
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

/// Generates Rust code from Anchor IDL files for the given programs.
///
/// - `idl_dir`: directory containing `{program}.json` IDL files
/// - `generated_dir`: output directory for generated Rust modules
/// - `programs`: program names to process (e.g. `["ics26_router", "ics07_tendermint"]`)
///
/// Returns a list of warning strings (e.g. naming conflicts).
pub fn generate_all(idl_dir: &Path, generated_dir: &Path, programs: &[&str]) -> Vec<String> {
    fs::create_dir_all(generated_dir).expect("Failed to create src/generated/ directory");

    let mut top_mod = String::from(
        "// AUTO-GENERATED FILE - DO NOT EDIT\n\
         // Generated by build.rs from Anchor IDL files\n\n",
    );
    let mut all_warnings = Vec::new();

    for program in programs {
        let idl_path = idl_dir.join(format!("{program}.json"));
        if !idl_path.exists() {
            println!(
                "cargo:warning=IDL not found for {program} at {}. Skipping.",
                idl_path.display()
            );
            continue;
        }

        let idl_content = fs::read_to_string(&idl_path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {e}", idl_path.display()));
        let idl: idl::Idl = serde_json::from_str(&idl_content)
            .unwrap_or_else(|e| panic!("Failed to parse {}: {e}", idl_path.display()));

        let program_dir = generated_dir.join(program);
        fs::create_dir_all(&program_dir)
            .unwrap_or_else(|e| panic!("Failed to create {}: {e}", program_dir.display()));

        let names = util::build_name_map(&idl);

        // Detect {InstructionPascalCase}Accounts vs type name overlap
        let type_names: BTreeSet<String> = names.values().cloned().collect();
        for ix in &idl.instructions {
            let accounts_name = format!("{}Accounts", util::to_pascal_case(&ix.name));
            if type_names.contains(&accounts_name) {
                all_warnings.push(format!(
                    "Program '{program}': instruction '{}' generates struct '{accounts_name}' \
                     which shadows a type name in types.rs",
                    ix.name,
                ));
            }
        }

        let has_types = type_gen::generate_types(program, &idl, &program_dir, &names);
        let has_accounts =
            type_gen::generate_accounts(program, &idl, &program_dir, has_types, &names);
        let (has_instructions, ix_warnings) = instruction_gen::generate_instructions(
            program,
            &idl,
            &program_dir,
            has_types,
            has_accounts,
            &names,
        );
        all_warnings.extend(ix_warnings);
        let has_events =
            type_gen::generate_events(&idl, &program_dir, has_types, has_accounts, &names);

        if has_types || has_accounts || has_instructions || has_events {
            util::generate_program_mod_rs(
                &program_dir,
                has_types,
                has_accounts,
                has_instructions,
                has_events,
            );
            writeln!(top_mod, "pub mod {program};").unwrap();
        }
    }

    fs::write(generated_dir.join("mod.rs"), top_mod).expect("Failed to write generated/mod.rs");

    format_generated_files(generated_dir);

    all_warnings
}

/// Runs `rustfmt` on all generated `.rs` files so that `cargo fmt` never
/// produces diffs on auto-generated code.
fn format_generated_files(dir: &Path) {
    let mut files = Vec::new();
    collect_rs_files(dir, &mut files);
    if files.is_empty() {
        return;
    }
    match std::process::Command::new("rustfmt").args(&files).status() {
        Ok(status) if !status.success() => {
            eprintln!("cargo:warning=rustfmt exited with non-zero status on generated files");
        }
        Err(e) => {
            eprintln!("cargo:warning=Could not run rustfmt on generated files: {e}");
        }
        _ => {}
    }
}

fn collect_rs_files(dir: &Path, files: &mut Vec<std::path::PathBuf>) {
    let Ok(entries) = fs::read_dir(dir) else {
        return;
    };
    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            collect_rs_files(&path, files);
        } else if path.extension().is_some_and(|e| e == "rs") {
            files.push(path);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_dir(name: &str) -> std::path::PathBuf {
        let dir = std::env::temp_dir().join(format!("codegen_test_{name}"));
        let _ = fs::remove_dir_all(&dir);
        dir
    }

    #[test]
    fn generate_all_skips_missing_idls() {
        let idl_dir = test_dir("gen_all_missing_idl");
        let generated_dir = test_dir("gen_all_missing_out");
        fs::create_dir_all(&idl_dir).unwrap();

        let warnings = generate_all(&idl_dir, &generated_dir, &["nonexistent"]);
        assert!(warnings.is_empty());

        let mod_rs = fs::read_to_string(generated_dir.join("mod.rs")).unwrap();
        assert!(!mod_rs.contains("pub mod nonexistent;"));
        assert!(mod_rs.contains("// AUTO-GENERATED FILE"));

        let _ = fs::remove_dir_all(&idl_dir);
        let _ = fs::remove_dir_all(&generated_dir);
    }

    #[test]
    fn generate_all_with_minimal_idl() {
        let idl_dir = test_dir("gen_all_minimal_idl");
        let generated_dir = test_dir("gen_all_minimal_out");
        fs::create_dir_all(&idl_dir).unwrap();

        let idl_json = r#"{
            "instructions": [{
                "name": "initialize",
                "discriminator": [1,2,3,4,5,6,7,8],
                "accounts": [{"name": "payer", "writable": true, "signer": true}],
                "args": []
            }],
            "types": [{
                "name": "test_prog::MyType",
                "type": {"kind": "struct", "fields": [{"name": "value", "type": "u64"}]}
            }],
            "events": [],
            "accounts": [{
                "name": "test_prog::MyType",
                "discriminator": [10,20,30,40,50,60,70,80]
            }]
        }"#;

        fs::write(idl_dir.join("test_prog.json"), idl_json).unwrap();

        let _ = generate_all(&idl_dir, &generated_dir, &["test_prog"]);

        let mod_rs = fs::read_to_string(generated_dir.join("mod.rs")).unwrap();
        assert!(mod_rs.contains("pub mod test_prog;"));

        let prog_mod = fs::read_to_string(generated_dir.join("test_prog/mod.rs")).unwrap();
        // MyType is an account, so it goes to accounts.rs, not types.rs
        assert!(!prog_mod.contains("pub mod types;"));
        assert!(prog_mod.contains("pub mod accounts;"));
        assert!(prog_mod.contains("pub mod instructions;"));
        assert!(!prog_mod.contains("pub mod events;"));

        let accounts = fs::read_to_string(generated_dir.join("test_prog/accounts.rs")).unwrap();
        assert!(accounts.contains("pub struct MyType {"));
        assert!(accounts.contains("pub value: u64,"));
        assert!(accounts.contains("impl MyType {"));
        assert!(accounts.contains("DISCRIMINATOR"));
        // No types.rs import since has_types is false
        assert!(!accounts.contains("use super::types::*;"));

        let instructions =
            fs::read_to_string(generated_dir.join("test_prog/instructions.rs")).unwrap();
        assert!(instructions.contains("pub struct Initialize;"));

        let _ = fs::remove_dir_all(&idl_dir);
        let _ = fs::remove_dir_all(&generated_dir);
    }

    #[test]
    fn generate_all_skips_program_with_empty_idl() {
        let idl_dir = test_dir("gen_all_empty_idl");
        let generated_dir = test_dir("gen_all_empty_out");
        fs::create_dir_all(&idl_dir).unwrap();

        let idl_json = r#"{"instructions": []}"#;
        fs::write(idl_dir.join("empty_prog.json"), idl_json).unwrap();

        let _ = generate_all(&idl_dir, &generated_dir, &["empty_prog"]);

        let mod_rs = fs::read_to_string(generated_dir.join("mod.rs")).unwrap();
        assert!(!mod_rs.contains("pub mod empty_prog;"));

        let _ = fs::remove_dir_all(&idl_dir);
        let _ = fs::remove_dir_all(&generated_dir);
    }

    #[test]
    fn generate_all_multiple_programs() {
        let idl_dir = test_dir("gen_all_multi_idl");
        let generated_dir = test_dir("gen_all_multi_out");
        fs::create_dir_all(&idl_dir).unwrap();

        let make_idl = |name: &str| {
            format!(
                r#"{{
                "instructions": [{{
                    "name": "init",
                    "discriminator": [0,0,0,0,0,0,0,0],
                    "accounts": [{{"name": "payer"}}]
                }}],
                "types": [{{
                    "name": "{name}::State",
                    "type": {{"kind": "struct", "fields": [{{"name": "v", "type": "u8"}}]}}
                }}],
                "accounts": [{{
                    "name": "{name}::State",
                    "discriminator": [1,2,3,4,5,6,7,8]
                }}]
            }}"#
            )
        };

        fs::write(idl_dir.join("prog_a.json"), make_idl("prog_a")).unwrap();
        fs::write(idl_dir.join("prog_b.json"), make_idl("prog_b")).unwrap();

        let _ = generate_all(&idl_dir, &generated_dir, &["prog_a", "prog_b", "missing"]);

        let mod_rs = fs::read_to_string(generated_dir.join("mod.rs")).unwrap();
        assert!(mod_rs.contains("pub mod prog_a;"));
        assert!(mod_rs.contains("pub mod prog_b;"));
        assert!(!mod_rs.contains("pub mod missing;"));

        let _ = fs::remove_dir_all(&idl_dir);
        let _ = fs::remove_dir_all(&generated_dir);
    }
}
