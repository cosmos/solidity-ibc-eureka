use std::collections::HashMap;
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

use crate::idl::Idl;

/// Maps each FQ IDL type name to its resolved Rust identifier.
pub type NameMap = HashMap<String, String>;

/// Returns the short (last `::` segment) name, pascal-cased.
///
/// e.g. `"solana_ibc_types::router::Packet"` → `"Packet"`
pub fn short_type_name(fq_name: &str) -> String {
    to_pascal_case(fq_name.rsplit("::").next().unwrap_or(fq_name))
}

/// Transforms a fully-qualified IDL type name into a Rust identifier.
///
/// Each `::` segment is pascal-cased and segments are joined with `_`.
/// e.g. `"ics26_router::state::Client"` → `"Ics26Router_State_Client"`
pub fn fq_type_name(fq_name: &str) -> String {
    fq_name
        .split("::")
        .map(to_pascal_case)
        .collect::<Vec<_>>()
        .join("_")
}

/// Builds a name map for all types in an IDL.
///
/// Uses the short name when unique, falls back to FQ name on collision.
pub fn build_name_map(idl: &Idl) -> NameMap {
    let mut short_to_fqs: HashMap<String, Vec<String>> = HashMap::new();
    for t in &idl.types {
        short_to_fqs
            .entry(short_type_name(&t.name))
            .or_default()
            .push(t.name.clone());
    }

    let mut map = NameMap::new();
    for (short, fqs) in &short_to_fqs {
        if fqs.len() == 1 {
            map.insert(fqs[0].clone(), short.clone());
        } else {
            for fq in fqs {
                map.insert(fq.clone(), fq_type_name(fq));
            }
        }
    }
    map
}

/// Escapes a name that is a Rust keyword so it can be used as an identifier.
///
/// Uses `syn` to detect keywords from the actual Rust grammar:
/// - Regular identifiers are returned unchanged
/// - Keywords eligible for raw syntax get a `r#` prefix
/// - Raw-ineligible keywords (`self`, `super`, `crate`, `Self`) get a `_` suffix
pub fn sanitize_ident(name: &str) -> String {
    if syn::parse_str::<syn::Ident>(name).is_ok() {
        return name.to_string();
    }
    if syn::parse_str::<syn::Ident>(&format!("r#{name}")).is_ok() {
        return format!("r#{name}");
    }
    format!("{name}_")
}

/// Converts `snake_case` to `PascalCase`.
pub fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            chars.next().map_or_else(String::new, |c| {
                let mut result = c.to_uppercase().to_string();
                result.extend(chars);
                result
            })
        })
        .collect()
}

/// Maps a well-known Solana address string to a Rust expression.
pub fn address_to_rust_expr(address: &str) -> String {
    match address {
        "11111111111111111111111111111111" => {
            "anchor_lang::solana_program::system_program::ID".to_string()
        }
        "Sysvar1nstructions1111111111111111111111111" => {
            "anchor_lang::solana_program::sysvar::instructions::ID".to_string()
        }
        other => format!("Pubkey::from_str_const(\"{other}\")"),
    }
}

#[allow(clippy::fn_params_excessive_bools)]
pub fn generate_program_mod_rs(
    program_dir: &Path,
    has_types: bool,
    has_accounts: bool,
    has_instructions: bool,
    has_events: bool,
) {
    let mut content = String::from(
        "// AUTO-GENERATED FILE - DO NOT EDIT\n\
         // Generated by build.rs\n\n",
    );

    if has_types {
        content.push_str("pub mod types;\n");
    }

    if has_accounts {
        content.push_str("pub mod accounts;\n");
    }

    if has_events {
        content.push_str("pub mod events;\n");
    }

    if has_instructions {
        content.push_str("pub mod instructions;\n");
    }

    let mod_path = program_dir.join("mod.rs");
    fs::write(&mod_path, content)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", mod_path.display()));
}

/// Writes the auto-generated file header common to all generated files.
pub fn write_file_header(output: &mut String) {
    writeln!(
        output,
        "// AUTO-GENERATED - do not edit\n\
         // Generated by build.rs from Anchor IDL files\n\
         \n\
         #![allow(non_camel_case_types, unused_imports)]\n\
         #![allow(clippy::doc_lazy_continuation, clippy::too_long_first_doc_paragraph)]\n"
    )
    .unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn pascal_case_conversions() {
        assert_eq!(to_pascal_case("recv_packet"), "RecvPacket");
        assert_eq!(
            to_pascal_case("assemble_and_update_client"),
            "AssembleAndUpdateClient"
        );
        assert_eq!(to_pascal_case("initialize"), "Initialize");
        assert_eq!(to_pascal_case("finalize_transfer"), "FinalizeTransfer");
    }

    #[test]
    fn pascal_case_empty_and_single() {
        assert_eq!(to_pascal_case(""), "");
        assert_eq!(to_pascal_case("x"), "X");
        assert_eq!(to_pascal_case("_leading"), "Leading");
    }

    #[test]
    fn well_known_addresses() {
        assert_eq!(
            address_to_rust_expr("11111111111111111111111111111111"),
            "anchor_lang::solana_program::system_program::ID"
        );
        assert_eq!(
            address_to_rust_expr("Sysvar1nstructions1111111111111111111111111"),
            "anchor_lang::solana_program::sysvar::instructions::ID"
        );
        assert_eq!(
            address_to_rust_expr("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            "Pubkey::from_str_const(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\")"
        );
    }

    #[test]
    fn short_type_name_extracts_last_segment() {
        assert_eq!(
            short_type_name("solana_ibc_types::router::Packet"),
            "Packet"
        );
        assert_eq!(
            short_type_name("ics26_router::state::router_state"),
            "RouterState"
        );
        assert_eq!(short_type_name("SimpleType"), "SimpleType");
        assert_eq!(short_type_name(""), "");
    }

    #[test]
    fn fq_type_name_transforms_segments() {
        assert_eq!(
            fq_type_name("ics26_router::events::SendPacketEvent"),
            "Ics26Router_Events_SendPacketEvent"
        );
        assert_eq!(
            fq_type_name("solana_ibc_types::router::Packet"),
            "SolanaIbcTypes_Router_Packet"
        );
        assert_eq!(fq_type_name("SimpleType"), "SimpleType");
    }

    #[test]
    fn fq_type_name_no_namespace() {
        assert_eq!(fq_type_name(""), "");
        assert_eq!(fq_type_name("AccountVersion"), "AccountVersion");
    }

    #[test]
    fn build_name_map_no_collisions() {
        use crate::idl::*;
        let idl = Idl {
            instructions: vec![],
            events: vec![],
            types: vec![
                IdlTypeDef {
                    name: "mod_a::Foo".into(),
                    docs: vec![],
                    type_def: IdlTypeDefBody {
                        kind: "struct".into(),
                        fields: vec![],
                        variants: vec![],
                    },
                },
                IdlTypeDef {
                    name: "mod_b::Bar".into(),
                    docs: vec![],
                    type_def: IdlTypeDefBody {
                        kind: "struct".into(),
                        fields: vec![],
                        variants: vec![],
                    },
                },
            ],
            accounts: vec![],
        };
        let map = build_name_map(&idl);
        assert_eq!(map["mod_a::Foo"], "Foo");
        assert_eq!(map["mod_b::Bar"], "Bar");
    }

    #[test]
    fn build_name_map_with_collision() {
        use crate::idl::*;
        let idl = Idl {
            instructions: vec![],
            events: vec![],
            types: vec![
                IdlTypeDef {
                    name: "mod_a::Shared".into(),
                    docs: vec![],
                    type_def: IdlTypeDefBody {
                        kind: "struct".into(),
                        fields: vec![],
                        variants: vec![],
                    },
                },
                IdlTypeDef {
                    name: "mod_b::Shared".into(),
                    docs: vec![],
                    type_def: IdlTypeDefBody {
                        kind: "struct".into(),
                        fields: vec![],
                        variants: vec![],
                    },
                },
                IdlTypeDef {
                    name: "mod_c::Unique".into(),
                    docs: vec![],
                    type_def: IdlTypeDefBody {
                        kind: "struct".into(),
                        fields: vec![],
                        variants: vec![],
                    },
                },
            ],
            accounts: vec![],
        };
        let map = build_name_map(&idl);
        assert_eq!(map["mod_a::Shared"], "ModA_Shared");
        assert_eq!(map["mod_b::Shared"], "ModB_Shared");
        assert_eq!(map["mod_c::Unique"], "Unique");
    }

    #[test]
    fn write_file_header_format() {
        let mut output = String::new();
        write_file_header(&mut output);
        assert!(output.contains("// AUTO-GENERATED - do not edit"));
        assert!(output.contains("#![allow(non_camel_case_types, unused_imports)]"));
        assert!(output.contains("clippy::doc_lazy_continuation"));
        assert!(output.contains("clippy::too_long_first_doc_paragraph"));
    }

    #[test]
    fn generate_mod_rs_all_modules() {
        let dir = std::env::temp_dir().join("codegen_test_mod_all");
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).unwrap();

        generate_program_mod_rs(&dir, true, true, true, true);
        let content = fs::read_to_string(dir.join("mod.rs")).unwrap();

        assert!(content.contains("pub mod types;"));
        assert!(content.contains("pub mod accounts;"));
        assert!(content.contains("pub mod events;"));
        assert!(content.contains("pub mod instructions;"));

        let _ = fs::remove_dir_all(&dir);
    }

    #[test]
    fn sanitize_ident_normal_names() {
        assert_eq!(sanitize_ident("amount"), "amount");
        assert_eq!(sanitize_ident("client_id"), "client_id");
        assert_eq!(sanitize_ident("payer"), "payer");
    }

    #[test]
    fn sanitize_ident_strict_keywords() {
        assert_eq!(sanitize_ident("type"), "r#type");
        assert_eq!(sanitize_ident("match"), "r#match");
        assert_eq!(sanitize_ident("async"), "r#async");
        assert_eq!(sanitize_ident("fn"), "r#fn");
        assert_eq!(sanitize_ident("use"), "r#use");
        assert_eq!(sanitize_ident("const"), "r#const");
        assert_eq!(sanitize_ident("enum"), "r#enum");
        assert_eq!(sanitize_ident("struct"), "r#struct");
    }

    #[test]
    fn sanitize_ident_reserved_keywords() {
        assert_eq!(sanitize_ident("try"), "r#try");
        assert_eq!(sanitize_ident("abstract"), "r#abstract");
        assert_eq!(sanitize_ident("yield"), "r#yield");
        assert_eq!(sanitize_ident("macro"), "r#macro");
    }

    #[test]
    fn sanitize_ident_raw_ineligible() {
        assert_eq!(sanitize_ident("self"), "self_");
        assert_eq!(sanitize_ident("super"), "super_");
        assert_eq!(sanitize_ident("crate"), "crate_");
        assert_eq!(sanitize_ident("Self"), "Self_");
    }

    #[test]
    fn generate_mod_rs_types_only() {
        let dir = std::env::temp_dir().join("codegen_test_mod_types");
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).unwrap();

        generate_program_mod_rs(&dir, true, false, false, false);
        let content = fs::read_to_string(dir.join("mod.rs")).unwrap();

        assert!(content.contains("pub mod types;"));
        assert!(!content.contains("pub mod accounts;"));
        assert!(!content.contains("pub mod events;"));
        assert!(!content.contains("pub mod instructions;"));

        let _ = fs::remove_dir_all(&dir);
    }
}
