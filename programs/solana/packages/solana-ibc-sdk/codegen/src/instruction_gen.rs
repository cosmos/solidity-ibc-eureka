use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::fmt::Write as _;
use std::fs;
use std::path::Path;

use crate::idl::{Idl, IdlFieldType, IdlInstruction, IdlInstructionAccount, IdlTypeDef};
use crate::pda::{self, ResolvedPda};
use crate::type_gen::idl_type_to_rust;
use crate::util::{address_to_rust_expr, sanitize_ident, to_pascal_case, NameMap};

/// Classification of instruction args for `build_instruction` signature generation.
enum ArgsKind {
    /// No args — `build_instruction` takes no args parameter.
    None,
    /// Single defined type — `build_instruction` takes a typed `&T` parameter.
    SingleDefined {
        /// Resolved Rust type name (e.g. `MsgRecvPacket`).
        type_name: String,
    },
    /// Multiple flat/mixed args — a `{Instruction}Args` struct is generated.
    Flat {
        /// Generated struct name (e.g. `FinalizeTransferArgs`).
        struct_name: String,
        /// Fields: `(sanitized_ident, rust_type)`.
        fields: Vec<(String, String)>,
    },
}

fn classify_args(ix: &IdlInstruction, names: &NameMap) -> ArgsKind {
    if ix.args.is_empty() {
        return ArgsKind::None;
    }

    if ix.args.len() == 1 {
        if let IdlFieldType::Defined { defined } = &ix.args[0].arg_type {
            let type_name = names
                .get(&defined.name)
                .cloned()
                .unwrap_or_else(|| defined.name.clone());
            return ArgsKind::SingleDefined { type_name };
        }
    }

    let struct_name = format!("{}Args", to_pascal_case(&ix.name));
    let fields = ix
        .args
        .iter()
        .map(|a| {
            let ident = sanitize_ident(&a.name);
            let rust_type = idl_type_to_rust(&a.arg_type, names);
            (ident, rust_type)
        })
        .collect();

    ArgsKind::Flat {
        struct_name,
        fields,
    }
}

pub fn generate_instructions(
    program: &str,
    idl: &Idl,
    program_dir: &Path,
    has_types: bool,
    has_accounts: bool,
    names: &NameMap,
) -> (bool, Vec<String>) {
    if idl.instructions.is_empty() {
        return (false, Vec::new());
    }

    let type_map: HashMap<&str, &IdlTypeDef> =
        idl.types.iter().map(|t| (t.name.as_str(), t)).collect();

    let (module_code, warnings) = generate_instruction_module(
        program,
        &idl.instructions,
        &type_map,
        has_types,
        has_accounts,
        names,
    );
    let instructions_path = program_dir.join("instructions.rs");
    fs::write(&instructions_path, &module_code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", instructions_path.display()));

    (true, warnings)
}

fn generate_instruction_module(
    program_name: &str,
    instructions: &[IdlInstruction],
    type_map: &HashMap<&str, &IdlTypeDef>,
    has_types: bool,
    has_accounts: bool,
    names: &NameMap,
) -> (String, Vec<String>) {
    let mut output = String::new();
    let mut warnings = Vec::new();
    let mut emitted_names = BTreeSet::new();

    let needs_borsh = instructions
        .iter()
        .any(|ix| !matches!(classify_args(ix, names), ArgsKind::None));

    writeln!(
        output,
        "// AUTO-GENERATED from {program_name} IDL - do not edit\n\
         // Generated by build.rs from Anchor IDL files\n\
         //\n\
         // These structs provide typed instruction account builders that match\n\
         // the exact account ordering defined in the Anchor program.\n\
         \n\
         #![allow(unused_imports)]\n\
         \n\
         use anchor_lang::solana_program::instruction::{{AccountMeta, Instruction}};\n\
         use anchor_lang::solana_program::pubkey::Pubkey;"
    )
    .unwrap();

    if needs_borsh {
        writeln!(
            output,
            "use anchor_lang::prelude::borsh::{{self, BorshDeserialize, BorshSerialize}};"
        )
        .unwrap();
    }

    if has_types {
        writeln!(output, "use super::types::*;").unwrap();
    }
    if has_accounts {
        writeln!(output, "use super::accounts::*;").unwrap();
    }

    writeln!(output).unwrap();

    for instruction in instructions {
        let struct_name = to_pascal_case(&instruction.name);
        if !emitted_names.insert(struct_name.clone()) {
            warnings.push(format!(
                "Instruction name collision: '{struct_name}' (from '{}') already emitted, \
                 skipping duplicate",
                instruction.name,
            ));
            continue;
        }
        generate_instruction_struct(&mut output, instruction, type_map, names);
    }

    (output, warnings)
}

/// Classification of an instruction account for code generation.
enum AccountKind {
    /// Fixed address (e.g. `system_program`) — not a struct field, hardcoded.
    Fixed,
    /// Auto-derivable PDA — not in Accounts struct, derived in `new()`.
    AutoPda { seed_refs: Vec<SeedRef> },
    /// Non-derivable account — `Pubkey` field in Accounts struct.
    Provided,
}

/// Reference to a PDA seed value: either an accounts-struct field or a typed arg.
enum SeedRef {
    /// References another instruction account's pubkey by field name.
    AccountField(String),
    /// References a typed arg field by name.
    ArgField(String),
}

/// A typed argument extracted from PDA seeds for the Accounts struct.
struct PdaArg {
    name: String,
    rust_type: String,
    needs_lifetime: bool,
}

fn classify_account(acc: &IdlInstructionAccount) -> AccountKind {
    if acc.address.is_some() {
        return AccountKind::Fixed;
    }

    let Some(pda) = &acc.pda else {
        return AccountKind::Provided;
    };

    if pda.program.is_some() {
        return AccountKind::Provided;
    }

    let has_account_field_path = pda
        .seeds
        .iter()
        .any(|s| s.kind == "account" && s.path.as_deref().is_some_and(|p| p.contains('.')));
    if has_account_field_path {
        return AccountKind::Provided;
    }

    let const_seeds: Vec<Vec<u8>> = pda
        .seeds
        .iter()
        .filter(|s| s.kind == "const")
        .filter_map(|s| s.value.clone())
        .collect();

    let first_seed_valid = const_seeds
        .first()
        .and_then(|s| std::str::from_utf8(s).ok())
        .is_some_and(|s| !s.is_empty());

    if !first_seed_valid {
        return AccountKind::Provided;
    }

    let mut seed_refs = Vec::new();
    let mut seen_leaves = BTreeSet::new();
    for seed in &pda.seeds {
        if seed.kind == "const" {
            continue;
        }
        let path = seed.path.as_deref().unwrap_or("");
        let leaf = path.rsplit('.').next().unwrap_or(path);

        if !seen_leaves.insert(leaf.to_string()) {
            continue;
        }

        if seed.kind == "account" {
            seed_refs.push(SeedRef::AccountField(leaf.to_string()));
        } else if seed.kind == "arg" {
            seed_refs.push(SeedRef::ArgField(leaf.to_string()));
        }
    }

    AccountKind::AutoPda { seed_refs }
}

/// Extracts typed PDA args from auto-derivable accounts.
fn extract_pda_args(
    classifications: &[(&IdlInstructionAccount, AccountKind)],
    resolved_pdas: &BTreeMap<String, ResolvedPda>,
) -> Vec<PdaArg> {
    let mut args = Vec::new();
    let mut seen = BTreeSet::new();

    for (acc, kind) in classifications {
        let AccountKind::AutoPda { seed_refs } = kind else {
            continue;
        };

        let Some(resolved) = resolved_pdas.get(&acc.name) else {
            continue;
        };

        for (seed_ref, param) in seed_refs.iter().zip(resolved.params.iter()) {
            let SeedRef::ArgField(name) = seed_ref else {
                continue;
            };

            if !seen.insert(name.clone()) {
                continue;
            }

            let (struct_type, needs_lifetime) = if param.rust_type == "&Pubkey" {
                ("Pubkey".to_string(), false)
            } else {
                (param.rust_type.clone(), param.rust_type.starts_with('&'))
            };

            args.push(PdaArg {
                name: name.clone(),
                rust_type: struct_type,
                needs_lifetime,
            });
        }
    }

    args
}

/// Builds the PDA derivation expression for `new()`.
fn pda_derive_expr(account_name: &str, seed_refs: &[SeedRef], resolved: &ResolvedPda) -> String {
    let mut args = Vec::new();

    for (i, seed_ref) in seed_refs.iter().enumerate() {
        let name = match seed_ref {
            SeedRef::AccountField(n) | SeedRef::ArgField(n) => n,
        };

        let needs_ref = match seed_ref {
            SeedRef::AccountField(_) => true,
            SeedRef::ArgField(_) => resolved
                .params
                .get(i)
                .is_some_and(|p| p.rust_type == "&Pubkey"),
        };

        let ident = sanitize_ident(name);
        if needs_ref {
            args.push(format!("&accounts.{ident}"));
        } else {
            args.push(format!("accounts.{ident}"));
        }
    }

    args.push("program_id".to_string());
    let method_name = format!("{}_pda", sanitize_ident(account_name));
    format!("Self::{method_name}({})", args.join(", "))
}

fn generate_instruction_struct(
    output: &mut String,
    instruction: &IdlInstruction,
    type_map: &HashMap<&str, &IdlTypeDef>,
    names: &NameMap,
) {
    let struct_name = to_pascal_case(&instruction.name);
    let accounts_name = format!("{struct_name}Accounts");
    let args_kind = classify_args(instruction, names);

    let classifications: Vec<(&IdlInstructionAccount, AccountKind)> = instruction
        .accounts
        .iter()
        .map(|acc| (acc, classify_account(acc)))
        .collect();

    // Resolve PDAs for each AutoPda account
    let resolved_pdas: BTreeMap<String, ResolvedPda> = classifications
        .iter()
        .filter(|(_, kind)| matches!(kind, AccountKind::AutoPda { .. }))
        .filter_map(|(acc, _)| {
            pda::resolve_account_pda(acc, &instruction.args, type_map)
                .map(|resolved| (acc.name.clone(), resolved))
        })
        .collect();

    let pda_args = extract_pda_args(&classifications, &resolved_pdas);
    let needs_lifetime = pda_args.iter().any(|a| a.needs_lifetime);

    let provided_accounts: Vec<&IdlInstructionAccount> = classifications
        .iter()
        .filter(|(_, kind)| matches!(kind, AccountKind::Provided))
        .map(|(acc, _)| *acc)
        .collect();

    // --- {Name}Accounts struct ---
    let lifetime = if needs_lifetime { "<'a>" } else { "" };
    let lifetime_for_impl = if needs_lifetime { "<'_>" } else { "" };

    writeln!(
        output,
        "\n/// Input accounts for the `{}` instruction.",
        instruction.name
    )
    .unwrap();
    writeln!(output, "pub struct {accounts_name}{lifetime} {{").unwrap();

    for acc in &provided_accounts {
        writeln!(output, "    pub {}: Pubkey,", sanitize_ident(&acc.name)).unwrap();
    }
    for arg in &pda_args {
        let ty = if arg.needs_lifetime {
            arg.rust_type.replacen('&', "&'a ", 1)
        } else {
            arg.rust_type.clone()
        };
        writeln!(output, "    pub {}: {ty},", sanitize_ident(&arg.name)).unwrap();
    }

    writeln!(output, "}}\n").unwrap();

    // --- {Name} struct (resolved, all Pubkeys) ---
    writeln!(
        output,
        "/// Resolved instruction accounts for `{}`.",
        instruction.name
    )
    .unwrap();
    writeln!(output, "pub struct {struct_name} {{").unwrap();
    writeln!(output, "    program_id: Pubkey,").unwrap();
    for (acc, kind) in &classifications {
        if matches!(kind, AccountKind::Fixed) {
            continue;
        }
        writeln!(output, "    {}: Pubkey,", sanitize_ident(&acc.name)).unwrap();
    }
    writeln!(output, "}}\n").unwrap();

    // --- impl ---
    writeln!(output, "impl {struct_name} {{").unwrap();

    writeln!(
        output,
        "    /// Total number of accounts (including fixed-address accounts)."
    )
    .unwrap();
    writeln!(
        output,
        "    pub const COUNT: usize = {};",
        instruction.accounts.len()
    )
    .unwrap();

    let disc_bytes: Vec<String> = instruction
        .discriminator
        .iter()
        .map(ToString::to_string)
        .collect();
    writeln!(output, "\n    /// Anchor instruction discriminator.").unwrap();
    writeln!(
        output,
        "    pub const DISCRIMINATOR: [u8; 8] = [{}];",
        disc_bytes.join(", ")
    )
    .unwrap();

    // --- PDA methods ---
    if !resolved_pdas.is_empty() {
        writeln!(output).unwrap();
    }
    for (acc, kind) in &classifications {
        if !matches!(kind, AccountKind::AutoPda { .. }) {
            continue;
        }
        if let Some(resolved) = resolved_pdas.get(&acc.name) {
            pda::generate_pda_method(output, &acc.name, resolved);
        }
    }

    // --- new() ---
    writeln!(
        output,
        "    /// Creates a new instruction builder, auto-deriving PDA accounts."
    )
    .unwrap();
    writeln!(output, "    #[must_use]").unwrap();
    writeln!(
        output,
        "    pub fn new(accounts: {accounts_name}{lifetime_for_impl}, program_id: &Pubkey) -> Self {{"
    )
    .unwrap();

    for (acc, kind) in &classifications {
        if let AccountKind::AutoPda { seed_refs } = kind {
            if let Some(resolved) = resolved_pdas.get(&acc.name) {
                let expr = pda_derive_expr(&acc.name, seed_refs, resolved);
                let ident = sanitize_ident(&acc.name);
                writeln!(output, "        let ({ident}, _) = {expr};").unwrap();
            }
        }
    }

    writeln!(output, "        Self {{").unwrap();
    writeln!(output, "            program_id: *program_id,").unwrap();
    for (acc, kind) in &classifications {
        let ident = sanitize_ident(&acc.name);
        match kind {
            AccountKind::Fixed => {}
            AccountKind::AutoPda { .. } => {
                writeln!(output, "            {ident},").unwrap();
            }
            AccountKind::Provided => {
                writeln!(output, "            {ident}: accounts.{ident},").unwrap();
            }
        }
    }
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();

    // --- to_account_metas() ---
    writeln!(
        output,
        "\n    /// Returns account metas in the order expected by the program."
    )
    .unwrap();
    writeln!(output, "    #[must_use]").unwrap();
    writeln!(
        output,
        "    pub fn to_account_metas(&self) -> Vec<AccountMeta> {{"
    )
    .unwrap();
    writeln!(output, "        vec![").unwrap();

    for account in &instruction.accounts {
        let pubkey_expr = account.address.as_ref().map_or_else(
            || format!("self.{}", sanitize_ident(&account.name)),
            |addr| address_to_rust_expr(addr),
        );

        let meta_expr = if account.writable {
            format!("AccountMeta::new({pubkey_expr}, {})", account.signer)
        } else {
            format!(
                "AccountMeta::new_readonly({pubkey_expr}, {})",
                account.signer
            )
        };

        writeln!(output, "            {meta_expr},").unwrap();
    }

    writeln!(output, "        ]").unwrap();
    writeln!(output, "    }}").unwrap();

    // --- Args struct (for flat args) ---
    if let ArgsKind::Flat {
        struct_name: ref args_struct_name,
        ref fields,
    } = args_kind
    {
        writeln!(output, "}}\n").unwrap();
        writeln!(
            output,
            "#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]"
        )
        .unwrap();
        writeln!(output, "pub struct {args_struct_name} {{").unwrap();
        for (ident, rust_type) in fields {
            writeln!(output, "    pub {ident}: {rust_type},").unwrap();
        }
        writeln!(output, "}}\n").unwrap();
        writeln!(output, "impl {struct_name} {{").unwrap();
    }

    // --- build_instruction() ---
    match &args_kind {
        ArgsKind::None => {
            writeln!(
                output,
                "\n    /// Builds a complete [`Instruction`] with discriminator and remaining accounts."
            )
            .unwrap();
            writeln!(output, "    #[must_use]").unwrap();
            writeln!(output, "    pub fn build_instruction(").unwrap();
            writeln!(output, "        self,").unwrap();
            writeln!(
                output,
                "        remaining_accounts: impl IntoIterator<Item = AccountMeta>,"
            )
            .unwrap();
            writeln!(output, "    ) -> Instruction {{").unwrap();
            writeln!(
                output,
                "        let mut accounts = self.to_account_metas();"
            )
            .unwrap();
            writeln!(output, "        accounts.extend(remaining_accounts);").unwrap();
            writeln!(
                output,
                "        Instruction {{ program_id: self.program_id, accounts, data: Self::DISCRIMINATOR.to_vec() }}"
            )
            .unwrap();
            writeln!(output, "    }}").unwrap();
        }
        ArgsKind::SingleDefined { type_name } => {
            writeln!(
                output,
                "\n    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts."
            )
            .unwrap();
            writeln!(output, "    #[must_use]").unwrap();
            writeln!(output, "    pub fn build_instruction(").unwrap();
            writeln!(output, "        self,").unwrap();
            writeln!(output, "        args: &{type_name},").unwrap();
            writeln!(
                output,
                "        remaining_accounts: impl IntoIterator<Item = AccountMeta>,"
            )
            .unwrap();
            writeln!(output, "    ) -> Instruction {{").unwrap();
            writeln!(
                output,
                "        let mut accounts = self.to_account_metas();"
            )
            .unwrap();
            writeln!(output, "        accounts.extend(remaining_accounts);").unwrap();
            writeln!(
                output,
                "        let mut data = Self::DISCRIMINATOR.to_vec();"
            )
            .unwrap();
            writeln!(
                output,
                "        data.extend_from_slice(&borsh::to_vec(args).expect(\"borsh serialize\"));"
            )
            .unwrap();
            writeln!(
                output,
                "        Instruction {{ program_id: self.program_id, accounts, data }}"
            )
            .unwrap();
            writeln!(output, "    }}").unwrap();
        }
        ArgsKind::Flat {
            struct_name: args_struct_name,
            ..
        } => {
            writeln!(
                output,
                "\n    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts."
            )
            .unwrap();
            writeln!(output, "    #[must_use]").unwrap();
            writeln!(output, "    pub fn build_instruction(").unwrap();
            writeln!(output, "        self,").unwrap();
            writeln!(output, "        args: &{args_struct_name},").unwrap();
            writeln!(
                output,
                "        remaining_accounts: impl IntoIterator<Item = AccountMeta>,"
            )
            .unwrap();
            writeln!(output, "    ) -> Instruction {{").unwrap();
            writeln!(
                output,
                "        let mut accounts = self.to_account_metas();"
            )
            .unwrap();
            writeln!(output, "        accounts.extend(remaining_accounts);").unwrap();
            writeln!(
                output,
                "        let mut data = Self::DISCRIMINATOR.to_vec();"
            )
            .unwrap();
            writeln!(
                output,
                "        data.extend_from_slice(&borsh::to_vec(args).expect(\"borsh serialize\"));"
            )
            .unwrap();
            writeln!(
                output,
                "        Instruction {{ program_id: self.program_id, accounts, data }}"
            )
            .unwrap();
            writeln!(output, "    }}").unwrap();
        }
    }

    writeln!(output, "}}\n").unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::idl::*;
    use crate::pda::{PdaParam, ResolvedPda};

    fn empty_names() -> NameMap {
        NameMap::new()
    }

    fn provided_account(name: &str) -> IdlInstructionAccount {
        IdlInstructionAccount {
            name: name.to_string(),
            writable: false,
            signer: false,
            address: None,
            pda: None,
        }
    }

    fn fixed_account(name: &str, address: &str) -> IdlInstructionAccount {
        IdlInstructionAccount {
            name: name.to_string(),
            writable: false,
            signer: false,
            address: Some(address.to_string()),
            pda: None,
        }
    }

    fn pda_account(name: &str, seeds: Vec<IdlPdaSeed>) -> IdlInstructionAccount {
        IdlInstructionAccount {
            name: name.to_string(),
            writable: false,
            signer: false,
            address: None,
            pda: Some(IdlPda {
                seeds,
                program: None,
            }),
        }
    }

    fn const_seed(value: &[u8]) -> IdlPdaSeed {
        IdlPdaSeed {
            kind: "const".to_string(),
            value: Some(value.to_vec()),
            path: None,
        }
    }

    fn account_seed(path: &str) -> IdlPdaSeed {
        IdlPdaSeed {
            kind: "account".to_string(),
            value: None,
            path: Some(path.to_string()),
        }
    }

    fn arg_seed(path: &str) -> IdlPdaSeed {
        IdlPdaSeed {
            kind: "arg".to_string(),
            value: None,
            path: Some(path.to_string()),
        }
    }

    #[test]
    fn classify_fixed_account() {
        let acc = fixed_account("system_program", "11111111111111111111111111111111");
        assert!(matches!(classify_account(&acc), AccountKind::Fixed));
    }

    #[test]
    fn classify_provided_account_no_pda() {
        let acc = provided_account("payer");
        assert!(matches!(classify_account(&acc), AccountKind::Provided));
    }

    #[test]
    fn classify_provided_cross_program_pda() {
        let acc = IdlInstructionAccount {
            name: "external".to_string(),
            writable: false,
            signer: false,
            address: None,
            pda: Some(IdlPda {
                seeds: vec![const_seed(b"some_seed")],
                program: Some(serde_json::json!({"kind": "account", "path": "program"})),
            }),
        };
        assert!(matches!(classify_account(&acc), AccountKind::Provided));
    }

    #[test]
    fn classify_provided_dot_path_account_seed() {
        let acc = pda_account(
            "derived",
            vec![const_seed(b"pfx"), account_seed("owner.key")],
        );
        assert!(matches!(classify_account(&acc), AccountKind::Provided));
    }

    #[test]
    fn classify_auto_pda_simple() {
        let acc = pda_account("my_pda", vec![const_seed(b"access_manager")]);
        match classify_account(&acc) {
            AccountKind::AutoPda { seed_refs } => {
                assert!(seed_refs.is_empty());
            }
            other => panic!(
                "Expected AutoPda, got {}",
                match other {
                    AccountKind::Fixed => "Fixed",
                    AccountKind::Provided => "Provided",
                    AccountKind::AutoPda { .. } => unreachable!(),
                }
            ),
        }
    }

    #[test]
    fn classify_auto_pda_with_seeds() {
        let acc = pda_account(
            "channel",
            vec![
                const_seed(b"channel"),
                account_seed("owner"),
                arg_seed("id"),
            ],
        );

        match classify_account(&acc) {
            AccountKind::AutoPda { seed_refs } => {
                assert_eq!(seed_refs.len(), 2);
                assert!(matches!(&seed_refs[0], SeedRef::AccountField(n) if n == "owner"));
                assert!(matches!(&seed_refs[1], SeedRef::ArgField(n) if n == "id"));
            }
            _ => panic!("Expected AutoPda"),
        }
    }

    #[test]
    fn basic_instruction_struct() {
        let instruction = IdlInstruction {
            name: "test_instruction".to_string(),
            discriminator: vec![1, 2, 3, 4, 5, 6, 7, 8],
            accounts: vec![
                IdlInstructionAccount {
                    name: "my_account".to_string(),
                    writable: true,
                    signer: false,
                    address: None,
                    pda: None,
                },
                IdlInstructionAccount {
                    name: "system_program".to_string(),
                    writable: false,
                    signer: false,
                    address: Some("11111111111111111111111111111111".to_string()),
                    pda: None,
                },
            ],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("pub struct TestInstructionAccounts"));
        assert!(output.contains("pub my_account: Pubkey,"));
        assert!(output.contains("pub struct TestInstruction {"));
        assert!(output.contains("pub const COUNT: usize = 2;"));
        assert!(output.contains("pub const DISCRIMINATOR: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];"));
        assert!(output.contains("AccountMeta::new(self.my_account, false)"));
        assert!(output.contains("anchor_lang::solana_program::system_program::ID"));
    }

    #[test]
    fn instruction_with_signer_and_writable() {
        let instruction = IdlInstruction {
            name: "transfer".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![
                IdlInstructionAccount {
                    name: "from".to_string(),
                    writable: true,
                    signer: true,
                    address: None,
                    pda: None,
                },
                IdlInstructionAccount {
                    name: "to".to_string(),
                    writable: true,
                    signer: false,
                    address: None,
                    pda: None,
                },
            ],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("AccountMeta::new(self.from, true)"));
        assert!(output.contains("AccountMeta::new(self.to, false)"));
    }

    #[test]
    fn instruction_with_readonly_sysvar() {
        let instruction = IdlInstruction {
            name: "check".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![fixed_account(
                "instructions_sysvar",
                "Sysvar1nstructions1111111111111111111111111",
            )],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("anchor_lang::solana_program::sysvar::instructions::ID"));
        assert!(output.contains("AccountMeta::new_readonly"));
    }

    #[test]
    fn instruction_with_auto_pda() {
        let instruction = IdlInstruction {
            name: "do_something".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![
                provided_account("payer"),
                pda_account("state", vec![const_seed(b"state")]),
            ],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        // state should NOT appear in Accounts struct (it's auto-derived)
        assert!(output.contains("pub struct DoSomethingAccounts"));
        assert!(output.contains("pub payer: Pubkey,"));
        // PDA method should be generated
        assert!(output.contains("pub fn state_pda(program_id: &Pubkey) -> (Pubkey, u8)"));
        // state should be derived via Self:: in new()
        assert!(output.contains("let (state, _) = Self::state_pda(program_id)"));
    }

    #[test]
    fn instruction_with_auto_pda_and_args() {
        let instruction = IdlInstruction {
            name: "create_channel".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![
                provided_account("payer"),
                pda_account(
                    "channel",
                    vec![
                        const_seed(b"channel"),
                        account_seed("owner"),
                        arg_seed("channel_id"),
                    ],
                ),
                provided_account("owner"),
            ],
            args: vec![IdlInstructionArg {
                name: "channel_id".to_string(),
                arg_type: IdlFieldType::Primitive("string".to_string()),
            }],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        // PDA method with params
        assert!(output.contains(
            "pub fn channel_pda(owner: &Pubkey, channel_id: &str, program_id: &Pubkey) -> (Pubkey, u8)"
        ));
        // Self:: call in new()
        assert!(
            output.contains("Self::channel_pda(&accounts.owner, accounts.channel_id, program_id)")
        );
        // channel_id should be in Accounts struct (PDA arg)
        assert!(output.contains("pub channel_id:"));
        // Flat args struct should be generated
        assert!(output.contains("pub struct CreateChannelArgs {"));
        assert!(output.contains("pub channel_id: String,"));
        // build_instruction should accept typed args
        assert!(output.contains("args: &CreateChannelArgs,"));
    }

    #[test]
    fn instruction_module_header() {
        let instructions = vec![IdlInstruction {
            name: "init".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![],
        }];

        let type_map = HashMap::new();
        let names = empty_names();
        let (output, warnings) = generate_instruction_module(
            "my_program",
            &instructions,
            &type_map,
            false,
            false,
            &names,
        );

        assert!(output.contains("// AUTO-GENERATED from my_program IDL - do not edit"));
        assert!(output
            .contains("use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};"));
        assert!(!output.contains("use super::accounts::pda;"));
        assert!(warnings.is_empty());
    }

    #[test]
    fn build_instruction_no_args() {
        let instruction = IdlInstruction {
            name: "simple".to_string(),
            discriminator: vec![42; 8],
            accounts: vec![provided_account("target")],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("pub fn build_instruction("));
        // No args parameter for no-args instructions
        assert!(!output.contains("args_data"));
        assert!(!output.contains("args:"));
        assert!(output.contains("remaining_accounts: impl IntoIterator<Item = AccountMeta>"));
        assert!(output.contains("Self::DISCRIMINATOR.to_vec()"));
    }

    #[test]
    fn build_instruction_single_defined_type() {
        let instruction = IdlInstruction {
            name: "recv_packet".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![provided_account("payer")],
            args: vec![IdlInstructionArg {
                name: "msg".to_string(),
                arg_type: IdlFieldType::Defined {
                    defined: IdlDefinedRef {
                        name: "my_mod::MsgRecvPacket".to_string(),
                    },
                },
            }],
        };

        let mut names = empty_names();
        names.insert(
            "my_mod::MsgRecvPacket".to_string(),
            "MsgRecvPacket".to_string(),
        );

        let type_map = HashMap::new();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("args: &MsgRecvPacket,"));
        assert!(!output.contains("pub struct RecvPacketArgs"));
        assert!(output.contains("borsh::to_vec(args)"));
    }

    #[test]
    fn build_instruction_flat_args() {
        let instruction = IdlInstruction {
            name: "finalize_transfer".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![provided_account("payer")],
            args: vec![
                IdlInstructionArg {
                    name: "client_id".to_string(),
                    arg_type: IdlFieldType::Primitive("string".to_string()),
                },
                IdlInstructionArg {
                    name: "sequence".to_string(),
                    arg_type: IdlFieldType::Primitive("u64".to_string()),
                },
            ],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        // Args struct should be generated
        assert!(output.contains("pub struct FinalizeTransferArgs {"));
        assert!(output.contains("pub client_id: String,"));
        assert!(output.contains("pub sequence: u64,"));
        assert!(output.contains("#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]"));
        // build_instruction should accept typed args
        assert!(output.contains("args: &FinalizeTransferArgs,"));
        assert!(output.contains("borsh::to_vec(args)"));
    }

    #[test]
    fn classify_args_no_args() {
        let ix = IdlInstruction {
            name: "noop".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![],
        };
        let names = empty_names();
        assert!(matches!(classify_args(&ix, &names), ArgsKind::None));
    }

    #[test]
    fn classify_args_single_defined() {
        let ix = IdlInstruction {
            name: "recv".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![IdlInstructionArg {
                name: "msg".to_string(),
                arg_type: IdlFieldType::Defined {
                    defined: IdlDefinedRef {
                        name: "MsgRecvPacket".to_string(),
                    },
                },
            }],
        };
        let names = empty_names();
        match classify_args(&ix, &names) {
            ArgsKind::SingleDefined { type_name } => {
                assert_eq!(type_name, "MsgRecvPacket");
            }
            _ => panic!("Expected SingleDefined"),
        }
    }

    #[test]
    fn classify_args_flat() {
        let ix = IdlInstruction {
            name: "grant_role".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![
                IdlInstructionArg {
                    name: "role_id".to_string(),
                    arg_type: IdlFieldType::Primitive("u64".to_string()),
                },
                IdlInstructionArg {
                    name: "account".to_string(),
                    arg_type: IdlFieldType::Primitive("pubkey".to_string()),
                },
            ],
        };
        let names = empty_names();
        match classify_args(&ix, &names) {
            ArgsKind::Flat {
                struct_name,
                fields,
            } => {
                assert_eq!(struct_name, "GrantRoleArgs");
                assert_eq!(fields.len(), 2);
                assert_eq!(fields[0], ("role_id".to_string(), "u64".to_string()));
                assert_eq!(fields[1], ("account".to_string(), "Pubkey".to_string()));
            }
            _ => panic!("Expected Flat"),
        }
    }

    #[test]
    fn classify_args_single_primitive_is_flat() {
        let ix = IdlInstruction {
            name: "set_admin".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![IdlInstructionArg {
                name: "new_admin".to_string(),
                arg_type: IdlFieldType::Primitive("pubkey".to_string()),
            }],
        };
        let names = empty_names();
        assert!(matches!(classify_args(&ix, &names), ArgsKind::Flat { .. }));
    }

    #[test]
    fn module_includes_borsh_import_when_args_exist() {
        let instructions = vec![IdlInstruction {
            name: "set_admin".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![provided_account("admin")],
            args: vec![IdlInstructionArg {
                name: "new_admin".to_string(),
                arg_type: IdlFieldType::Primitive("pubkey".to_string()),
            }],
        }];

        let type_map = HashMap::new();
        let names = empty_names();
        let (output, _) = generate_instruction_module(
            "test_prog",
            &instructions,
            &type_map,
            false,
            false,
            &names,
        );

        assert!(output.contains(
            "use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};"
        ));
    }

    #[test]
    fn module_no_borsh_import_when_no_args() {
        let instructions = vec![IdlInstruction {
            name: "noop".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![],
        }];

        let type_map = HashMap::new();
        let names = empty_names();
        let (output, _) = generate_instruction_module(
            "test_prog",
            &instructions,
            &type_map,
            false,
            false,
            &names,
        );

        assert!(!output.contains("borsh"));
    }

    #[test]
    fn module_includes_types_import_when_has_types() {
        let instructions = vec![IdlInstruction {
            name: "init".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![],
        }];

        let type_map = HashMap::new();
        let names = empty_names();
        let (output, _) =
            generate_instruction_module("test_prog", &instructions, &type_map, true, false, &names);

        assert!(output.contains("use super::types::*;"));
    }

    #[test]
    fn extract_pda_args_with_str_param() {
        let acc = pda_account("state", vec![const_seed(b"state"), arg_seed("client_id")]);
        let classifications = vec![(&acc, classify_account(&acc))];

        let mut resolved_pdas = BTreeMap::new();
        resolved_pdas.insert(
            "state".to_string(),
            ResolvedPda {
                const_seeds: vec![b"state".to_vec()],
                params: vec![PdaParam {
                    name: "client_id".to_string(),
                    rust_type: "&str".to_string(),
                    seed_expr: "client_id.as_bytes()".to_string(),
                }],
            },
        );

        let args = extract_pda_args(&classifications, &resolved_pdas);
        assert_eq!(args.len(), 1);
        assert_eq!(args[0].name, "client_id");
        assert_eq!(args[0].rust_type, "&str");
        assert!(args[0].needs_lifetime);
    }

    #[test]
    fn extract_pda_args_pubkey_becomes_owned() {
        let acc = pda_account("state", vec![const_seed(b"state"), arg_seed("owner")]);
        let classifications = vec![(&acc, classify_account(&acc))];

        let mut resolved_pdas = BTreeMap::new();
        resolved_pdas.insert(
            "state".to_string(),
            ResolvedPda {
                const_seeds: vec![b"state".to_vec()],
                params: vec![PdaParam {
                    name: "owner".to_string(),
                    rust_type: "&Pubkey".to_string(),
                    seed_expr: "owner.as_ref()".to_string(),
                }],
            },
        );

        let args = extract_pda_args(&classifications, &resolved_pdas);
        assert_eq!(args[0].rust_type, "Pubkey");
        assert!(!args[0].needs_lifetime);
    }

    #[test]
    fn pda_derive_expr_account_ref() {
        let resolved = ResolvedPda {
            const_seeds: vec![b"channel".to_vec()],
            params: vec![PdaParam {
                name: "owner".to_string(),
                rust_type: "&Pubkey".to_string(),
                seed_expr: "owner.as_ref()".to_string(),
            }],
        };

        let seed_refs = vec![SeedRef::AccountField("owner".to_string())];
        let expr = pda_derive_expr("channel", &seed_refs, &resolved);
        assert_eq!(expr, "Self::channel_pda(&accounts.owner, program_id)");
    }

    #[test]
    fn pda_derive_expr_arg_pubkey_ref() {
        let resolved = ResolvedPda {
            const_seeds: vec![b"state".to_vec()],
            params: vec![PdaParam {
                name: "key".to_string(),
                rust_type: "&Pubkey".to_string(),
                seed_expr: "key.as_ref()".to_string(),
            }],
        };

        let seed_refs = vec![SeedRef::ArgField("key".to_string())];
        let expr = pda_derive_expr("state", &seed_refs, &resolved);
        assert_eq!(expr, "Self::state_pda(&accounts.key, program_id)");
    }

    #[test]
    fn pda_derive_expr_arg_non_pubkey_no_ref() {
        let resolved = ResolvedPda {
            const_seeds: vec![b"state".to_vec()],
            params: vec![PdaParam {
                name: "id".to_string(),
                rust_type: "&str".to_string(),
                seed_expr: "id.as_bytes()".to_string(),
            }],
        };

        let seed_refs = vec![SeedRef::ArgField("id".to_string())];
        let expr = pda_derive_expr("state", &seed_refs, &resolved);
        assert_eq!(expr, "Self::state_pda(accounts.id, program_id)");
    }

    #[test]
    fn pda_derive_expr_no_seeds() {
        let resolved = ResolvedPda {
            const_seeds: vec![b"state".to_vec()],
            params: vec![],
        };

        let seed_refs = vec![];
        let expr = pda_derive_expr("state", &seed_refs, &resolved);
        assert_eq!(expr, "Self::state_pda(program_id)");
    }

    #[test]
    fn instruction_with_no_accounts() {
        let instruction = IdlInstruction {
            name: "noop".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("pub struct NoopAccounts"));
        assert!(output.contains("pub const COUNT: usize = 0;"));
        assert!(output.contains("vec![\n        ]"));
    }

    #[test]
    fn instruction_with_only_auto_derived_pda() {
        let instruction = IdlInstruction {
            name: "auto_only".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![pda_account("state", vec![const_seed(b"state")])],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        // Accounts struct should have no fields (the PDA is auto-derived)
        assert!(output.contains("pub struct AutoOnlyAccounts {\n}\n"));
    }

    #[test]
    fn instruction_with_only_fixed_accounts() {
        let instruction = IdlInstruction {
            name: "fixed_only".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![
                fixed_account("system_program", "11111111111111111111111111111111"),
                fixed_account(
                    "instructions_sysvar",
                    "Sysvar1nstructions1111111111111111111111111",
                ),
            ],
            args: vec![],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        // Accounts struct should have no fields
        assert!(output.contains("pub struct FixedOnlyAccounts {\n}\n"));
        assert!(output.contains("pub const COUNT: usize = 2;"));
    }

    #[test]
    fn generate_instructions_returns_false_for_empty() {
        let dir = std::env::temp_dir().join("codegen_test_ix_empty");
        let _ = std::fs::remove_dir_all(&dir);
        std::fs::create_dir_all(&dir).unwrap();

        let idl = Idl {
            instructions: vec![],
            events: vec![],
            types: vec![],
            accounts: vec![],
        };

        let names = empty_names();
        let (generated, warnings) = generate_instructions("prog", &idl, &dir, false, false, &names);
        assert!(!generated);
        assert!(warnings.is_empty());

        let _ = std::fs::remove_dir_all(&dir);
    }

    #[test]
    fn instruction_name_collision_detected() {
        let instructions = vec![
            IdlInstruction {
                name: "do_thing".to_string(),
                discriminator: vec![0; 8],
                accounts: vec![],
                args: vec![],
            },
            IdlInstruction {
                name: "doThing".to_string(),
                discriminator: vec![1; 8],
                accounts: vec![],
                args: vec![],
            },
        ];

        let type_map = HashMap::new();
        let names = empty_names();
        let (output, warnings) =
            generate_instruction_module("test", &instructions, &type_map, false, false, &names);

        assert_eq!(warnings.len(), 1);
        assert!(warnings[0].contains("DoThing"));
        assert_eq!(output.matches("pub struct DoThing {").count(), 1);
    }

    #[test]
    fn extract_pda_args_skips_account_field_seeds() {
        let acc = pda_account(
            "state",
            vec![const_seed(b"state"), account_seed("owner"), arg_seed("id")],
        );
        let classifications = vec![(&acc, classify_account(&acc))];

        let mut resolved_pdas = BTreeMap::new();
        resolved_pdas.insert(
            "state".to_string(),
            ResolvedPda {
                const_seeds: vec![b"state".to_vec()],
                params: vec![
                    PdaParam {
                        name: "owner".to_string(),
                        rust_type: "&Pubkey".to_string(),
                        seed_expr: "owner.as_ref()".to_string(),
                    },
                    PdaParam {
                        name: "id".to_string(),
                        rust_type: "&str".to_string(),
                        seed_expr: "id.as_bytes()".to_string(),
                    },
                ],
            },
        );

        let args = extract_pda_args(&classifications, &resolved_pdas);
        // Only "id" should be extracted (owner is an AccountField, not ArgField)
        assert_eq!(args.len(), 1);
        assert_eq!(args[0].name, "id");
    }

    #[test]
    fn extract_pda_args_skips_unknown_pda() {
        let acc = pda_account("unknown", vec![const_seed(b"missing")]);
        let classifications = vec![(&acc, classify_account(&acc))];

        let resolved_pdas = BTreeMap::new(); // empty — no matching PDA
        let args = extract_pda_args(&classifications, &resolved_pdas);
        assert!(args.is_empty());
    }

    #[test]
    fn flat_args_keyword_field_sanitized() {
        let instruction = IdlInstruction {
            name: "set_type".to_string(),
            discriminator: vec![0; 8],
            accounts: vec![],
            args: vec![IdlInstructionArg {
                name: "type".to_string(),
                arg_type: IdlFieldType::Primitive("u8".to_string()),
            }],
        };

        let type_map = HashMap::new();
        let names = empty_names();
        let mut output = String::new();
        generate_instruction_struct(&mut output, &instruction, &type_map, &names);

        assert!(output.contains("pub r#type: u8,"));
    }
}
