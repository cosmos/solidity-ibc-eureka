// AUTO-GENERATED from access_manager IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `initialize`.
pub struct Initialize;

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> InitializeBuilder {
        InitializeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub admin: Pubkey,
}

/// Builder for the `initialize` instruction.
pub struct InitializeBuilder {
    program_id: Pubkey,
    accounts: Option<InitializeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl InitializeBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: InitializeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &InitializeArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = Initialize::access_manager_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(access_manager, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `grant_role` instruction.
pub struct GrantRoleAccounts {
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `grant_role`.
pub struct GrantRole;

impl GrantRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [218, 234, 128, 15, 82, 33, 236, 253];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> GrantRoleBuilder {
        GrantRoleBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct GrantRoleArgs {
    pub role_id: u64,
    pub account: Pubkey,
}

/// Builder for the `grant_role` instruction.
pub struct GrantRoleBuilder {
    program_id: Pubkey,
    accounts: Option<GrantRoleAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl GrantRoleBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: GrantRoleAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &GrantRoleArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = GrantRole::access_manager_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(access_manager, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `revoke_role` instruction.
pub struct RevokeRoleAccounts {
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `revoke_role`.
pub struct RevokeRole;

impl RevokeRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [179, 232, 2, 180, 48, 227, 82, 7];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> RevokeRoleBuilder {
        RevokeRoleBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RevokeRoleArgs {
    pub role_id: u64,
    pub account: Pubkey,
}

/// Builder for the `revoke_role` instruction.
pub struct RevokeRoleBuilder {
    program_id: Pubkey,
    accounts: Option<RevokeRoleAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl RevokeRoleBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: RevokeRoleAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &RevokeRoleArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = RevokeRole::access_manager_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(access_manager, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `renounce_role` instruction.
pub struct RenounceRoleAccounts {
    pub caller: Pubkey,
}

/// Instruction constants and PDA helpers for `renounce_role`.
pub struct RenounceRole;

impl RenounceRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [21, 253, 233, 162, 186, 216, 217, 26];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> RenounceRoleBuilder {
        RenounceRoleBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RenounceRoleArgs {
    pub role_id: u64,
}

/// Builder for the `renounce_role` instruction.
pub struct RenounceRoleBuilder {
    program_id: Pubkey,
    accounts: Option<RenounceRoleAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl RenounceRoleBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: RenounceRoleAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &RenounceRoleArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = RenounceRole::access_manager_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(access_manager, false),
            AccountMeta::new_readonly(accounts.caller, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `upgrade_program` instruction.
pub struct UpgradeProgramAccounts {
    pub program: Pubkey,
    pub program_data: Pubkey,
    pub buffer: Pubkey,
    pub spill: Pubkey,
    pub authority: Pubkey,
    pub target_program: Pubkey,
}

/// Instruction constants and PDA helpers for `upgrade_program`.
pub struct UpgradeProgram;

impl UpgradeProgram {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 11;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [223, 236, 39, 89, 111, 204, 114, 37];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    #[must_use]
    pub fn upgrade_authority_pda(target_program: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"upgrade_authority", target_program.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> UpgradeProgramBuilder {
        UpgradeProgramBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct UpgradeProgramArgs {
    pub target_program: Pubkey,
}

/// Builder for the `upgrade_program` instruction.
pub struct UpgradeProgramBuilder {
    program_id: Pubkey,
    accounts: Option<UpgradeProgramAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl UpgradeProgramBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: UpgradeProgramAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &UpgradeProgramArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = UpgradeProgram::access_manager_pda(&self.program_id);
        let (upgrade_authority, _) =
            UpgradeProgram::upgrade_authority_pda(&accounts.target_program, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(access_manager, false),
            AccountMeta::new(accounts.program, false),
            AccountMeta::new(accounts.program_data, false),
            AccountMeta::new(accounts.buffer, false),
            AccountMeta::new(upgrade_authority, false),
            AccountMeta::new(accounts.spill, false),
            AccountMeta::new_readonly(accounts.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("BPFLoaderUpgradeab1e11111111111111111111111"),
                false,
            ),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("SysvarRent111111111111111111111111111111111"),
                false,
            ),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("SysvarC1ock11111111111111111111111111111111"),
                false,
            ),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_whitelisted_programs` instruction.
pub struct SetWhitelistedProgramsAccounts {
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_whitelisted_programs`.
pub struct SetWhitelistedPrograms;

impl SetWhitelistedPrograms {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [215, 39, 132, 81, 64, 65, 123, 123];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetWhitelistedProgramsBuilder {
        SetWhitelistedProgramsBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetWhitelistedProgramsArgs {
    pub whitelisted_programs: Vec<Pubkey>,
}

/// Builder for the `set_whitelisted_programs` instruction.
pub struct SetWhitelistedProgramsBuilder {
    program_id: Pubkey,
    accounts: Option<SetWhitelistedProgramsAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetWhitelistedProgramsBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: SetWhitelistedProgramsAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetWhitelistedProgramsArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (access_manager, _) = SetWhitelistedPrograms::access_manager_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(access_manager, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}
