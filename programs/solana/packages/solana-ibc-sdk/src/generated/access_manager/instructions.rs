// AUTO-GENERATED from access_manager IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `initialize`.
pub struct Initialize {
    program_id: Pubkey,
    access_manager: Pubkey,
    payer: Pubkey,
}

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: InitializeAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        Self {
            program_id: *program_id,
            access_manager,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.access_manager, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub admin: Pubkey,
}

impl Initialize {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &InitializeArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `grant_role` instruction.
pub struct GrantRoleAccounts {
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `grant_role`.
pub struct GrantRole {
    program_id: Pubkey,
    access_manager: Pubkey,
    admin: Pubkey,
}

impl GrantRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [218, 234, 128, 15, 82, 33, 236, 253];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: GrantRoleAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        Self {
            program_id: *program_id,
            access_manager,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.access_manager, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct GrantRoleArgs {
    pub role_id: u64,
    pub account: Pubkey,
}

impl GrantRole {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &GrantRoleArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `revoke_role` instruction.
pub struct RevokeRoleAccounts {
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `revoke_role`.
pub struct RevokeRole {
    program_id: Pubkey,
    access_manager: Pubkey,
    admin: Pubkey,
}

impl RevokeRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [179, 232, 2, 180, 48, 227, 82, 7];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RevokeRoleAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        Self {
            program_id: *program_id,
            access_manager,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.access_manager, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RevokeRoleArgs {
    pub role_id: u64,
    pub account: Pubkey,
}

impl RevokeRole {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &RevokeRoleArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `renounce_role` instruction.
pub struct RenounceRoleAccounts {
    pub caller: Pubkey,
}

/// Resolved instruction accounts for `renounce_role`.
pub struct RenounceRole {
    program_id: Pubkey,
    access_manager: Pubkey,
    caller: Pubkey,
}

impl RenounceRole {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [21, 253, 233, 162, 186, 216, 217, 26];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RenounceRoleAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        Self {
            program_id: *program_id,
            access_manager,
            caller: accounts.caller,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.access_manager, false),
            AccountMeta::new_readonly(self.caller, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RenounceRoleArgs {
    pub role_id: u64,
}

impl RenounceRole {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &RenounceRoleArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `upgrade_program` instruction.
pub struct UpgradeProgramAccounts {
    pub program: Pubkey,
    pub program_data: Pubkey,
    pub buffer: Pubkey,
    pub spill: Pubkey,
    pub authority: Pubkey,
    pub target_program: Pubkey,
}

/// Resolved instruction accounts for `upgrade_program`.
pub struct UpgradeProgram {
    program_id: Pubkey,
    access_manager: Pubkey,
    program: Pubkey,
    program_data: Pubkey,
    buffer: Pubkey,
    upgrade_authority: Pubkey,
    spill: Pubkey,
    authority: Pubkey,
}

impl UpgradeProgram {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 11;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [223, 236, 39, 89, 111, 204, 114, 37];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    #[must_use]
    pub fn upgrade_authority_pda(target_program: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"upgrade_authority", target_program.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: UpgradeProgramAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        let (upgrade_authority, _) =
            Self::upgrade_authority_pda(&accounts.target_program, program_id);
        Self {
            program_id: *program_id,
            access_manager,
            program: accounts.program,
            program_data: accounts.program_data,
            buffer: accounts.buffer,
            upgrade_authority,
            spill: accounts.spill,
            authority: accounts.authority,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.program, false),
            AccountMeta::new(self.program_data, false),
            AccountMeta::new(self.buffer, false),
            AccountMeta::new(self.upgrade_authority, false),
            AccountMeta::new(self.spill, false),
            AccountMeta::new_readonly(self.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("BPFLoaderUpgradeab1e11111111111111111111111"),
                false,
            ),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("SysvarRent111111111111111111111111111111111"),
                false,
            ),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("SysvarC1ock11111111111111111111111111111111"),
                false,
            ),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct UpgradeProgramArgs {
    pub target_program: Pubkey,
}

impl UpgradeProgram {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &UpgradeProgramArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_whitelisted_programs` instruction.
pub struct SetWhitelistedProgramsAccounts {
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_whitelisted_programs`.
pub struct SetWhitelistedPrograms {
    program_id: Pubkey,
    access_manager: Pubkey,
    admin: Pubkey,
}

impl SetWhitelistedPrograms {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [215, 39, 132, 81, 64, 65, 123, 123];

    #[must_use]
    pub fn access_manager_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"access_manager"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetWhitelistedProgramsAccounts, program_id: &Pubkey) -> Self {
        let (access_manager, _) = Self::access_manager_pda(program_id);
        Self {
            program_id: *program_id,
            access_manager,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.access_manager, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetWhitelistedProgramsArgs {
    pub whitelisted_programs: Vec<Pubkey>,
}

impl SetWhitelistedPrograms {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &SetWhitelistedProgramsArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}
