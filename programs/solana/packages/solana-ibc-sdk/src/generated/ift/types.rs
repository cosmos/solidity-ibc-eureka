// AUTO-GENERATED - do not edit
// Generated by build.rs from Anchor IDL files

#![allow(non_camel_case_types, unused_imports)]
#![allow(clippy::doc_lazy_continuation, clippy::too_long_first_doc_paragraph)]

use anchor_lang::prelude::*;
use anchor_lang::solana_program::pubkey::Pubkey;

/// Message for admin mint
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct AdminMintMsg {
    /// Receiver pubkey
    pub receiver: Pubkey,
    /// Amount to mint
    pub amount: u64,
}

/// Status of a GMP call result.
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum CallResultStatus {
    Acknowledgement([u8; 32]),
    Timeout,
}

/// Chain-specific options for counterparty chain configuration
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum ChainOptions {
    Evm,
    Cosmos {
        denom: String,
        type_url: String,
        ica_address: String,
    },
}

/// Token type and configuration for `create_and_initialize_spl_token`
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum CreateTokenParams {
    SplToken {
        decimals: u8,
    },
    Token2022 {
        decimals: u8,
        name: String,
        symbol: String,
        uri: String,
    },
}

/// Persisted outcome of a cross-chain GMP call.
/// Created when the ICS26 router delivers an acknowledgement or timeout
/// callback to the GMP app. Stores either the IBC acknowledgement
/// commitment hash (on success/failure) or a timeout marker, so the
/// original sender can query the result on-chain after the round-trip
/// completes.
/// # PDA Seeds
/// `["gmp_result", source_client, sequence (little-endian u64)]`
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct GMPCallResultAccount {
    /// Account schema version for future upgrades.
    pub version: Ics27Gmp_State_AccountVersion,
    /// Original sender pubkey.
    pub sender: Pubkey,
    /// IBC packet sequence number (namespaced: `base_seq * 10000 + hash(app, sender) % 10000`).
    pub sequence: u64,
    /// Source client ID (light client on this chain tracking the destination).
    pub source_client: String,
    /// Destination client ID (light client on the destination chain).
    pub dest_client: String,
    /// Result status: acknowledgement (with IBC commitment) or timeout.
    pub status: CallResultStatus,
    /// Unix timestamp (seconds) when the result was recorded.
    pub result_timestamp: i64,
    /// PDA bump seed.
    pub bump: u8,
}

/// Message for minting IFT tokens (called by GMP)
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct IFTMintMsg {
    /// Receiver pubkey
    pub receiver: Pubkey,
    /// Amount to mint
    pub amount: u64,
}

/// Message for initiating an IFT transfer
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct IFTTransferMsg {
    /// IBC client identifier for destination
    pub client_id: String,
    /// Receiver address on destination chain
    pub receiver: String,
    /// Amount to transfer
    pub amount: u64,
    /// Timeout timestamp (0 for default 15 minutes)
    pub timeout_timestamp: i64,
}

/// Account schema version
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum Ics27Gmp_State_AccountVersion {
    V1,
}

/// Account schema version for upgrades
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum Ift_State_AccountVersion {
    V1,
}

/// Reason for transfer refund
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum RefundReason {
    Timeout,
    Failed,
}

/// Message for registering an IFT bridge
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct RegisterIFTBridgeMsg {
    /// IBC client identifier
    pub client_id: String,
    /// Counterparty IFT contract address
    pub counterparty_ift_address: String,
    /// Chain-specific options
    pub chain_options: ChainOptions,
}

/// Message for setting the daily mint rate limit
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct SetMintRateLimitMsg {
    /// Daily mint limit (0 = no limit)
    pub daily_mint_limit: u64,
}

/// Message for pausing/unpausing an IFT token
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct SetPausedMsg {
    /// Whether to pause (true) or unpause (false) the token
    pub paused: bool,
}
