// AUTO-GENERATED from ift IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `initialize`.
pub struct Initialize;

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> InitializeBuilder {
        InitializeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub admin: Pubkey,
}

/// Builder for the `initialize` instruction.
pub struct InitializeBuilder {
    program_id: Pubkey,
    accounts: Option<InitializeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl InitializeBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: InitializeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &InitializeArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = Initialize::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `create_and_initialize_spl_token` instruction.
pub struct CreateAndInitializeSplTokenAccounts {
    pub mint: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `create_and_initialize_spl_token`.
pub struct CreateAndInitializeSplToken;

impl CreateAndInitializeSplToken {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 9;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [185, 46, 222, 165, 24, 238, 239, 60];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> CreateAndInitializeSplTokenBuilder {
        CreateAndInitializeSplTokenBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `create_and_initialize_spl_token` instruction.
pub struct CreateAndInitializeSplTokenBuilder {
    program_id: Pubkey,
    accounts: Option<CreateAndInitializeSplTokenAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl CreateAndInitializeSplTokenBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: CreateAndInitializeSplTokenAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &CreateTokenParams) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = CreateAndInitializeSplToken::app_state_pda(&self.program_id);
        let (app_mint_state, _) =
            CreateAndInitializeSplToken::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) =
            CreateAndInitializeSplToken::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(app_mint_state, false),
            AccountMeta::new(accounts.mint, true),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `initialize_existing_token` instruction.
pub struct InitializeExistingTokenAccounts {
    pub mint: Pubkey,
    pub current_authority: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `initialize_existing_token`.
pub struct InitializeExistingToken;

impl InitializeExistingToken {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [202, 36, 198, 101, 164, 90, 18, 233];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> InitializeExistingTokenBuilder {
        InitializeExistingTokenBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `initialize_existing_token` instruction.
pub struct InitializeExistingTokenBuilder {
    program_id: Pubkey,
    accounts: Option<InitializeExistingTokenAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl InitializeExistingTokenBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: InitializeExistingTokenAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = InitializeExistingToken::app_state_pda(&self.program_id);
        let (app_mint_state, _) =
            InitializeExistingToken::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) =
            InitializeExistingToken::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(app_mint_state, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new_readonly(accounts.current_authority, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `register_ift_bridge` instruction.
pub struct RegisterIftBridgeAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `register_ift_bridge`.
pub struct RegisterIftBridge;

impl RegisterIftBridge {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 7;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [1, 217, 101, 187, 58, 31, 161, 168];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> RegisterIftBridgeBuilder {
        RegisterIftBridgeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `register_ift_bridge` instruction.
pub struct RegisterIftBridgeBuilder {
    program_id: Pubkey,
    accounts: Option<RegisterIftBridgeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl RegisterIftBridgeBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: RegisterIftBridgeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &RegisterIFTBridgeMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = RegisterIftBridge::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(accounts.app_mint_state, false),
            AccountMeta::new(accounts.ift_bridge, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `remove_ift_bridge` instruction.
pub struct RemoveIftBridgeAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `remove_ift_bridge`.
pub struct RemoveIftBridge;

impl RemoveIftBridge {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 7;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [43, 130, 95, 216, 72, 197, 239, 67];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> RemoveIftBridgeBuilder {
        RemoveIftBridgeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct RemoveIftBridgeArgs {
    pub client_id: String,
}

/// Builder for the `remove_ift_bridge` instruction.
pub struct RemoveIftBridgeBuilder {
    program_id: Pubkey,
    accounts: Option<RemoveIftBridgeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl RemoveIftBridgeBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: RemoveIftBridgeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &RemoveIftBridgeArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = RemoveIftBridge::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(accounts.app_mint_state, false),
            AccountMeta::new(accounts.ift_bridge, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `ift_transfer` instruction.
pub struct IftTransferAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub mint: Pubkey,
    pub sender_token_account: Pubkey,
    pub sender: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
    pub gmp_app_state: Pubkey,
    pub router_state: Pubkey,
    pub client_sequence: Pubkey,
    pub packet_commitment: Pubkey,
    pub gmp_ibc_app: Pubkey,
    pub ibc_client: Pubkey,
    pub light_client_program: Pubkey,
    pub light_client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub pending_transfer: Pubkey,
}

/// Instruction constants and PDA helpers for `ift_transfer`.
pub struct IftTransfer;

impl IftTransfer {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 22;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [90, 149, 241, 191, 75, 3, 50, 100];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> IftTransferBuilder {
        IftTransferBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `ift_transfer` instruction.
pub struct IftTransferBuilder {
    program_id: Pubkey,
    accounts: Option<IftTransferAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl IftTransferBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: IftTransferAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &IFTTransferMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = IftTransfer::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(accounts.app_mint_state, false),
            AccountMeta::new_readonly(accounts.ift_bridge, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new(accounts.sender_token_account, false),
            AccountMeta::new_readonly(accounts.sender, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("3W3h4WSE8J9vFzVN8TGFGc9Uchbry3M4MBz4icdSWcFi"),
                false,
            ),
            AccountMeta::new(accounts.gmp_app_state, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx"),
                false,
            ),
            AccountMeta::new_readonly(accounts.router_state, false),
            AccountMeta::new(accounts.client_sequence, false),
            AccountMeta::new(accounts.packet_commitment, false),
            AccountMeta::new_readonly(accounts.gmp_ibc_app, false),
            AccountMeta::new_readonly(accounts.ibc_client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.light_client_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
            AccountMeta::new(accounts.pending_transfer, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `ift_mint` instruction.
pub struct IftMintAccounts {
    pub ift_bridge: Pubkey,
    pub mint: Pubkey,
    pub receiver_token_account: Pubkey,
    pub receiver_owner: Pubkey,
    pub gmp_account: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `ift_mint`.
pub struct IftMint;

impl IftMint {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [156, 201, 217, 144, 114, 175, 170, 83];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> IftMintBuilder {
        IftMintBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `ift_mint` instruction.
pub struct IftMintBuilder {
    program_id: Pubkey,
    accounts: Option<IftMintAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl IftMintBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: IftMintAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &IFTMintMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = IftMint::app_state_pda(&self.program_id);
        let (app_mint_state, _) = IftMint::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) = IftMint::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(app_mint_state, false),
            AccountMeta::new_readonly(accounts.ift_bridge, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new(accounts.receiver_token_account, false),
            AccountMeta::new_readonly(accounts.receiver_owner, false),
            AccountMeta::new_readonly(accounts.gmp_account, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            ),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `finalize_transfer` instruction.
pub struct FinalizeTransferAccounts {
    pub ift_bridge: Pubkey,
    pub pending_transfer: Pubkey,
    pub gmp_result: Pubkey,
    pub mint: Pubkey,
    pub sender_token_account: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `finalize_transfer`.
pub struct FinalizeTransfer;

impl FinalizeTransfer {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [124, 126, 103, 188, 144, 65, 135, 51];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> FinalizeTransferBuilder {
        FinalizeTransferBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct FinalizeTransferArgs {
    pub client_id: String,
    pub sequence: u64,
}

/// Builder for the `finalize_transfer` instruction.
pub struct FinalizeTransferBuilder {
    program_id: Pubkey,
    accounts: Option<FinalizeTransferAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl FinalizeTransferBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: FinalizeTransferAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &FinalizeTransferArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = FinalizeTransfer::app_state_pda(&self.program_id);
        let (app_mint_state, _) =
            FinalizeTransfer::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) =
            FinalizeTransfer::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(app_mint_state, false),
            AccountMeta::new_readonly(accounts.ift_bridge, false),
            AccountMeta::new(accounts.pending_transfer, false),
            AccountMeta::new_readonly(accounts.gmp_result, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new(accounts.sender_token_account, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_admin` instruction.
pub struct SetAdminAccounts {
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_admin`.
pub struct SetAdmin;

impl SetAdmin {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [251, 163, 0, 52, 91, 194, 187, 92];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetAdminBuilder {
        SetAdminBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetAdminArgs {
    pub new_admin: Pubkey,
}

/// Builder for the `set_admin` instruction.
pub struct SetAdminBuilder {
    program_id: Pubkey,
    accounts: Option<SetAdminAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetAdminBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SetAdminAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetAdminArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SetAdmin::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `revoke_mint_authority` instruction.
pub struct RevokeMintAuthorityAccounts {
    pub mint: Pubkey,
    pub new_mint_authority: Pubkey,
    pub admin: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `revoke_mint_authority`.
pub struct RevokeMintAuthority;

impl RevokeMintAuthority {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [140, 52, 61, 238, 209, 157, 189, 32];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> RevokeMintAuthorityBuilder {
        RevokeMintAuthorityBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `revoke_mint_authority` instruction.
pub struct RevokeMintAuthorityBuilder {
    program_id: Pubkey,
    accounts: Option<RevokeMintAuthorityAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl RevokeMintAuthorityBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: RevokeMintAuthorityAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = RevokeMintAuthority::app_state_pda(&self.program_id);
        let (app_mint_state, _) =
            RevokeMintAuthority::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) =
            RevokeMintAuthority::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(app_mint_state, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new_readonly(accounts.new_mint_authority, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_mint_rate_limit` instruction.
pub struct SetMintRateLimitAccounts {
    pub app_mint_state: Pubkey,
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_mint_rate_limit`.
pub struct SetMintRateLimit;

impl SetMintRateLimit {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [130, 207, 16, 33, 36, 175, 200, 83];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetMintRateLimitBuilder {
        SetMintRateLimitBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `set_mint_rate_limit` instruction.
pub struct SetMintRateLimitBuilder {
    program_id: Pubkey,
    accounts: Option<SetMintRateLimitAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetMintRateLimitBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SetMintRateLimitAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetMintRateLimitMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SetMintRateLimit::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(accounts.app_mint_state, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_paused` instruction.
pub struct SetPausedAccounts {
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_paused`.
pub struct SetPaused;

impl SetPaused {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [91, 60, 125, 192, 176, 225, 166, 218];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetPausedBuilder {
        SetPausedBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `set_paused` instruction.
pub struct SetPausedBuilder {
    program_id: Pubkey,
    accounts: Option<SetPausedAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetPausedBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SetPausedAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetPausedMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SetPaused::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `admin_mint` instruction.
pub struct AdminMintAccounts {
    pub mint: Pubkey,
    pub receiver_token_account: Pubkey,
    pub receiver_owner: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Instruction constants and PDA helpers for `admin_mint`.
pub struct AdminMint;

impl AdminMint {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [137, 144, 88, 222, 36, 159, 250, 217];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> AdminMintBuilder {
        AdminMintBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `admin_mint` instruction.
pub struct AdminMintBuilder {
    program_id: Pubkey,
    accounts: Option<AdminMintAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl AdminMintBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: AdminMintAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &AdminMintMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = AdminMint::app_state_pda(&self.program_id);
        let (app_mint_state, _) = AdminMint::app_mint_state_pda(&accounts.mint, &self.program_id);
        let (mint_authority, _) = AdminMint::mint_authority_pda(&accounts.mint, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new(app_mint_state, false),
            AccountMeta::new(accounts.mint, false),
            AccountMeta::new_readonly(mint_authority, false),
            AccountMeta::new(accounts.receiver_token_account, false),
            AccountMeta::new_readonly(accounts.receiver_owner, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.token_program, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            ),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}
