// AUTO-GENERATED from ift IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `initialize`.
pub struct Initialize {
    program_id: Pubkey,
    app_state: Pubkey,
    payer: Pubkey,
}

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: InitializeAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.app_state, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `create_and_initialize_spl_token` instruction.
pub struct CreateAndInitializeSplTokenAccounts {
    pub mint: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `create_and_initialize_spl_token`.
pub struct CreateAndInitializeSplToken {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    admin: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
}

impl CreateAndInitializeSplToken {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 9;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [185, 46, 222, 165, 24, 238, 239, 60];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: CreateAndInitializeSplTokenAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            mint: accounts.mint,
            mint_authority,
            admin: accounts.admin,
            payer: accounts.payer,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new(self.mint, true),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `initialize_existing_token` instruction.
pub struct InitializeExistingTokenAccounts {
    pub mint: Pubkey,
    pub current_authority: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `initialize_existing_token`.
pub struct InitializeExistingToken {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    current_authority: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
}

impl InitializeExistingToken {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [202, 36, 198, 101, 164, 90, 18, 233];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: InitializeExistingTokenAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            mint: accounts.mint,
            mint_authority,
            current_authority: accounts.current_authority,
            payer: accounts.payer,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new_readonly(self.current_authority, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `register_ift_bridge` instruction.
pub struct RegisterIftBridgeAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `register_ift_bridge`.
pub struct RegisterIftBridge {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    ift_bridge: Pubkey,
    admin: Pubkey,
    payer: Pubkey,
}

impl RegisterIftBridge {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 7;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [1, 217, 101, 187, 58, 31, 161, 168];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RegisterIftBridgeAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state: accounts.app_mint_state,
            ift_bridge: accounts.ift_bridge,
            admin: accounts.admin,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new_readonly(self.app_mint_state, false),
            AccountMeta::new(self.ift_bridge, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `remove_ift_bridge` instruction.
pub struct RemoveIftBridgeAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `remove_ift_bridge`.
pub struct RemoveIftBridge {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    ift_bridge: Pubkey,
    admin: Pubkey,
    payer: Pubkey,
}

impl RemoveIftBridge {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 7;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [43, 130, 95, 216, 72, 197, 239, 67];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RemoveIftBridgeAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state: accounts.app_mint_state,
            ift_bridge: accounts.ift_bridge,
            admin: accounts.admin,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new_readonly(self.app_mint_state, false),
            AccountMeta::new(self.ift_bridge, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `ift_transfer` instruction.
pub struct IftTransferAccounts {
    pub app_mint_state: Pubkey,
    pub ift_bridge: Pubkey,
    pub mint: Pubkey,
    pub sender_token_account: Pubkey,
    pub sender: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
    pub gmp_app_state: Pubkey,
    pub router_state: Pubkey,
    pub client_sequence: Pubkey,
    pub packet_commitment: Pubkey,
    pub gmp_ibc_app: Pubkey,
    pub ibc_client: Pubkey,
    pub light_client_program: Pubkey,
    pub light_client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub pending_transfer: Pubkey,
}

/// Resolved instruction accounts for `ift_transfer`.
pub struct IftTransfer {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    ift_bridge: Pubkey,
    mint: Pubkey,
    sender_token_account: Pubkey,
    sender: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
    gmp_app_state: Pubkey,
    router_state: Pubkey,
    client_sequence: Pubkey,
    packet_commitment: Pubkey,
    gmp_ibc_app: Pubkey,
    ibc_client: Pubkey,
    light_client_program: Pubkey,
    light_client_state: Pubkey,
    consensus_state: Pubkey,
    pending_transfer: Pubkey,
}

impl IftTransfer {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 22;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [90, 149, 241, 191, 75, 3, 50, 100];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: IftTransferAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state: accounts.app_mint_state,
            ift_bridge: accounts.ift_bridge,
            mint: accounts.mint,
            sender_token_account: accounts.sender_token_account,
            sender: accounts.sender,
            payer: accounts.payer,
            token_program: accounts.token_program,
            gmp_app_state: accounts.gmp_app_state,
            router_state: accounts.router_state,
            client_sequence: accounts.client_sequence,
            packet_commitment: accounts.packet_commitment,
            gmp_ibc_app: accounts.gmp_ibc_app,
            ibc_client: accounts.ibc_client,
            light_client_program: accounts.light_client_program,
            light_client_state: accounts.light_client_state,
            consensus_state: accounts.consensus_state,
            pending_transfer: accounts.pending_transfer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new_readonly(self.app_mint_state, false),
            AccountMeta::new_readonly(self.ift_bridge, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new(self.sender_token_account, false),
            AccountMeta::new_readonly(self.sender, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("3W3h4WSE8J9vFzVN8TGFGc9Uchbry3M4MBz4icdSWcFi"),
                false,
            ),
            AccountMeta::new(self.gmp_app_state, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx"),
                false,
            ),
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new(self.client_sequence, false),
            AccountMeta::new(self.packet_commitment, false),
            AccountMeta::new_readonly(self.gmp_ibc_app, false),
            AccountMeta::new_readonly(self.ibc_client, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(self.light_client_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(self.consensus_state, false),
            AccountMeta::new(self.pending_transfer, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `ift_mint` instruction.
pub struct IftMintAccounts {
    pub ift_bridge: Pubkey,
    pub mint: Pubkey,
    pub receiver_token_account: Pubkey,
    pub receiver_owner: Pubkey,
    pub gmp_account: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `ift_mint`.
pub struct IftMint {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    ift_bridge: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    receiver_token_account: Pubkey,
    receiver_owner: Pubkey,
    gmp_account: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
}

impl IftMint {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [156, 201, 217, 144, 114, 175, 170, 83];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: IftMintAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            ift_bridge: accounts.ift_bridge,
            mint: accounts.mint,
            mint_authority,
            receiver_token_account: accounts.receiver_token_account,
            receiver_owner: accounts.receiver_owner,
            gmp_account: accounts.gmp_account,
            payer: accounts.payer,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new_readonly(self.ift_bridge, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new(self.receiver_token_account, false),
            AccountMeta::new_readonly(self.receiver_owner, false),
            AccountMeta::new_readonly(self.gmp_account, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            ),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `finalize_transfer` instruction.
pub struct FinalizeTransferAccounts {
    pub ift_bridge: Pubkey,
    pub pending_transfer: Pubkey,
    pub gmp_result: Pubkey,
    pub mint: Pubkey,
    pub sender_token_account: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `finalize_transfer`.
pub struct FinalizeTransfer {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    ift_bridge: Pubkey,
    pending_transfer: Pubkey,
    gmp_result: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    sender_token_account: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
}

impl FinalizeTransfer {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [124, 126, 103, 188, 144, 65, 135, 51];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: FinalizeTransferAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            ift_bridge: accounts.ift_bridge,
            pending_transfer: accounts.pending_transfer,
            gmp_result: accounts.gmp_result,
            mint: accounts.mint,
            mint_authority,
            sender_token_account: accounts.sender_token_account,
            payer: accounts.payer,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new_readonly(self.ift_bridge, false),
            AccountMeta::new(self.pending_transfer, false),
            AccountMeta::new_readonly(self.gmp_result, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new(self.sender_token_account, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_admin` instruction.
pub struct SetAdminAccounts {
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_admin`.
pub struct SetAdmin {
    program_id: Pubkey,
    app_state: Pubkey,
    admin: Pubkey,
}

impl SetAdmin {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [251, 163, 0, 52, 91, 194, 187, 92];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetAdminAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.app_state, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `revoke_mint_authority` instruction.
pub struct RevokeMintAuthorityAccounts {
    pub mint: Pubkey,
    pub new_mint_authority: Pubkey,
    pub admin: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `revoke_mint_authority`.
pub struct RevokeMintAuthority {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    new_mint_authority: Pubkey,
    admin: Pubkey,
    token_program: Pubkey,
}

impl RevokeMintAuthority {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [140, 52, 61, 238, 209, 157, 189, 32];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RevokeMintAuthorityAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            mint: accounts.mint,
            mint_authority,
            new_mint_authority: accounts.new_mint_authority,
            admin: accounts.admin,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new_readonly(self.app_mint_state, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new_readonly(self.new_mint_authority, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_mint_rate_limit` instruction.
pub struct SetMintRateLimitAccounts {
    pub app_mint_state: Pubkey,
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_mint_rate_limit`.
pub struct SetMintRateLimit {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    admin: Pubkey,
}

impl SetMintRateLimit {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [130, 207, 16, 33, 36, 175, 200, 83];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetMintRateLimitAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state: accounts.app_mint_state,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_paused` instruction.
pub struct SetPausedAccounts {
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_paused`.
pub struct SetPaused {
    program_id: Pubkey,
    app_state: Pubkey,
    admin: Pubkey,
}

impl SetPaused {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [91, 60, 125, 192, 176, 225, 166, 218];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetPausedAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.app_state, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `admin_mint` instruction.
pub struct AdminMintAccounts {
    pub mint: Pubkey,
    pub receiver_token_account: Pubkey,
    pub receiver_owner: Pubkey,
    pub admin: Pubkey,
    pub payer: Pubkey,
    pub token_program: Pubkey,
}

/// Resolved instruction accounts for `admin_mint`.
pub struct AdminMint {
    program_id: Pubkey,
    app_state: Pubkey,
    app_mint_state: Pubkey,
    mint: Pubkey,
    mint_authority: Pubkey,
    receiver_token_account: Pubkey,
    receiver_owner: Pubkey,
    admin: Pubkey,
    payer: Pubkey,
    token_program: Pubkey,
}

impl AdminMint {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 12;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [137, 144, 88, 222, 36, 159, 250, 217];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_state"], program_id)
    }

    #[must_use]
    pub fn app_mint_state_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_app_mint_state", mint.as_ref()], program_id)
    }

    #[must_use]
    pub fn mint_authority_pda(mint: &Pubkey, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ift_mint_authority", mint.as_ref()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: AdminMintAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        let (app_mint_state, _) = Self::app_mint_state_pda(&accounts.mint, program_id);
        let (mint_authority, _) = Self::mint_authority_pda(&accounts.mint, program_id);
        Self {
            program_id: *program_id,
            app_state,
            app_mint_state,
            mint: accounts.mint,
            mint_authority,
            receiver_token_account: accounts.receiver_token_account,
            receiver_owner: accounts.receiver_owner,
            admin: accounts.admin,
            payer: accounts.payer,
            token_program: accounts.token_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new(self.app_mint_state, false),
            AccountMeta::new(self.mint, false),
            AccountMeta::new_readonly(self.mint_authority, false),
            AccountMeta::new(self.receiver_token_account, false),
            AccountMeta::new_readonly(self.receiver_owner, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.token_program, false),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
                false,
            ),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}
