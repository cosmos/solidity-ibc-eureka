// AUTO-GENERATED - do not edit
// Generated by build.rs from Anchor IDL files

#![allow(non_camel_case_types, unused_imports)]

use anchor_lang::prelude::*;
use anchor_lang::solana_program::pubkey::Pubkey;

/// Account schema version for upgradability
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub enum AccountVersion {
    V1,
}

/// Client account structure mapping client IDs to light client program IDs
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ClientAccount {
    /// Schema version for upgrades
    pub version: AccountVersion,
    /// The client identifier
    pub client_id: String,
    /// The program ID of the light client
    pub client_program_id: Pubkey,
    /// Counterparty chain information
    pub counterparty_info: CounterpartyInfo,
    /// Whether the client is active
    pub active: bool,
    /// Reserved space for future fields
    pub _reserved: [u8; 256],
}

/// Counterparty chain information
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct CounterpartyInfo {
    /// Client ID on the counterparty chain
    pub client_id: String,
    /// Merkle prefix for proof verification
    pub merkle_prefix: Vec<Vec<u8>>,
}

/// Parameters for migrating a client
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MigrateClientParams {
    /// New light client program ID (None = keep current)
    pub client_program_id: Option<Pubkey>,
    /// New counterparty info (None = keep current)
    pub counterparty_info: Option<CounterpartyInfo>,
    /// New active status (None = keep current)
    pub active: Option<bool>,
}

/// Message for acknowledging a packet
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgAckPacket {
    pub packet: Packet,
    pub payloads: Vec<PayloadMetadata>,
    pub acknowledgement: Vec<u8>,
    pub proof: ProofMetadata,
}

/// Message for cleanup
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgCleanupChunks {
    pub client_id: String,
    pub sequence: u64,
    pub payload_chunks: Vec<u8>,
    pub total_proof_chunks: u8,
}

/// Message for receiving a packet
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgRecvPacket {
    pub packet: Packet,
    pub payloads: Vec<PayloadMetadata>,
    pub proof: ProofMetadata,
}

/// Message for sending a packet
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgSendPacket {
    pub source_client: String,
    pub timeout_timestamp: i64,
    pub payload: Payload,
}

/// Message for timing out a packet
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgTimeoutPacket {
    pub packet: Packet,
    pub payloads: Vec<PayloadMetadata>,
    pub proof: ProofMetadata,
}

/// Message for uploading chunks
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct MsgUploadChunk {
    pub client_id: String,
    pub sequence: u64,
    pub payload_index: u8,
    pub chunk_index: u8,
    pub chunk_data: Vec<u8>,
}

/// Packet structure matching Ethereum's ICS26RouterMsgs.Packet
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Packet {
    pub sequence: u64,
    pub source_client: String,
    pub dest_client: String,
    pub timeout_timestamp: i64,
    pub payloads: Vec<Payload>,
}

/// Payload structure shared between router and IBC apps
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Payload {
    pub source_port: String,
    pub dest_port: String,
    pub version: String,
    pub encoding: String,
    pub value: Vec<u8>,
}

/// Payload metadata for chunked operations
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct PayloadMetadata {
    pub source_port: String,
    pub dest_port: String,
    pub version: String,
    pub encoding: String,
    pub total_chunks: u8,
}

/// Proof metadata for chunked operations
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct ProofMetadata {
    pub height: u64,
    pub total_chunks: u8,
}
