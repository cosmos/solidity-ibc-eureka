// AUTO-GENERATED from ics26_router IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `initialize`.
pub struct Initialize;

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> InitializeBuilder {
        InitializeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub access_manager: Pubkey,
}

/// Builder for the `initialize` instruction.
pub struct InitializeBuilder {
    program_id: Pubkey,
    accounts: Option<InitializeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl InitializeBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: InitializeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &InitializeArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = Initialize::router_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(router_state, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `add_ibc_app` instruction.
pub struct AddIbcAppAccounts<'a> {
    pub access_manager: Pubkey,
    pub app_program: Pubkey,
    pub payer: Pubkey,
    pub authority: Pubkey,
    pub port_id: &'a str,
}

/// Instruction constants and PDA helpers for `add_ibc_app`.
pub struct AddIbcApp;

impl AddIbcApp {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [233, 201, 201, 149, 2, 13, 134, 27];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(port_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", port_id.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> AddIbcAppBuilder<'a> {
        AddIbcAppBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AddIbcAppArgs {
    pub port_id: String,
}

/// Builder for the `add_ibc_app` instruction.
pub struct AddIbcAppBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<AddIbcAppAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> AddIbcAppBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: AddIbcAppAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &AddIbcAppArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = AddIbcApp::router_state_pda(&self.program_id);
        let (ibc_app, _) = AddIbcApp::ibc_app_pda(accounts.port_id, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(ibc_app, false),
            AccountMeta::new_readonly(accounts.app_program, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(accounts.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `send_packet` instruction.
pub struct SendPacketAccounts<'a> {
    pub packet_commitment: Pubkey,
    pub app_signer: Pubkey,
    pub payer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a str,
    pub source_client: &'a str,
}

/// Instruction constants and PDA helpers for `send_packet`.
pub struct SendPacket;

impl SendPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 11;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [242, 7, 23, 143, 124, 157, 42, 102];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_sequence_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client_sequence", source_client.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> SendPacketBuilder<'a> {
        SendPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `send_packet` instruction.
pub struct SendPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<SendPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> SendPacketBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: SendPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgSendPacket) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = SendPacket::router_state_pda(&self.program_id);
        let (ibc_app, _) = SendPacket::ibc_app_pda(accounts.source_port, &self.program_id);
        let (client_sequence, _) =
            SendPacket::client_sequence_pda(accounts.source_client, &self.program_id);
        let (client, _) = SendPacket::client_pda(accounts.source_client, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(ibc_app, false),
            AccountMeta::new(client_sequence, false),
            AccountMeta::new(accounts.packet_commitment, false),
            AccountMeta::new_readonly(accounts.app_signer, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `recv_packet` instruction.
pub struct RecvPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub dest_port: &'a [u8],
    pub dest_client: &'a str,
    pub sequence: u64,
}

/// Instruction constants and PDA helpers for `recv_packet`.
pub struct RecvPacket;

impl RecvPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 14;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [130, 14, 240, 161, 35, 63, 45, 71];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(dest_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", dest_port], program_id)
    }

    #[must_use]
    pub fn packet_receipt_pda(
        dest_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_receipt",
                dest_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn packet_ack_pda(dest_client: &str, sequence: u64, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_ack",
                dest_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(dest_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", dest_client.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> RecvPacketBuilder<'a> {
        RecvPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `recv_packet` instruction.
pub struct RecvPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<RecvPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> RecvPacketBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: RecvPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgRecvPacket) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = RecvPacket::router_state_pda(&self.program_id);
        let (ibc_app, _) = RecvPacket::ibc_app_pda(accounts.dest_port, &self.program_id);
        let (packet_receipt, _) = RecvPacket::packet_receipt_pda(
            accounts.dest_client,
            accounts.sequence,
            &self.program_id,
        );
        let (packet_ack, _) =
            RecvPacket::packet_ack_pda(accounts.dest_client, accounts.sequence, &self.program_id);
        let (client, _) = RecvPacket::client_pda(accounts.dest_client, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(ibc_app, false),
            AccountMeta::new(packet_receipt, false),
            AccountMeta::new(packet_ack, false),
            AccountMeta::new_readonly(accounts.ibc_app_program, false),
            AccountMeta::new(accounts.ibc_app_state, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `ack_packet` instruction.
pub struct AckPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a [u8],
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Instruction constants and PDA helpers for `ack_packet`.
pub struct AckPacket;

impl AckPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 13;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [43, 194, 45, 54, 2, 40, 211, 228];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port], program_id)
    }

    #[must_use]
    pub fn packet_commitment_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_commitment",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> AckPacketBuilder<'a> {
        AckPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `ack_packet` instruction.
pub struct AckPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<AckPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> AckPacketBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: AckPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgAckPacket) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = AckPacket::router_state_pda(&self.program_id);
        let (ibc_app, _) = AckPacket::ibc_app_pda(accounts.source_port, &self.program_id);
        let (packet_commitment, _) = AckPacket::packet_commitment_pda(
            accounts.source_client,
            accounts.sequence,
            &self.program_id,
        );
        let (client, _) = AckPacket::client_pda(accounts.source_client, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(ibc_app, false),
            AccountMeta::new(packet_commitment, false),
            AccountMeta::new_readonly(accounts.ibc_app_program, false),
            AccountMeta::new(accounts.ibc_app_state, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `timeout_packet` instruction.
pub struct TimeoutPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a [u8],
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Instruction constants and PDA helpers for `timeout_packet`.
pub struct TimeoutPacket;

impl TimeoutPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 13;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [224, 56, 82, 83, 77, 13, 120, 103];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port], program_id)
    }

    #[must_use]
    pub fn packet_commitment_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_commitment",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> TimeoutPacketBuilder<'a> {
        TimeoutPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `timeout_packet` instruction.
pub struct TimeoutPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<TimeoutPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> TimeoutPacketBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: TimeoutPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgTimeoutPacket) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = TimeoutPacket::router_state_pda(&self.program_id);
        let (ibc_app, _) = TimeoutPacket::ibc_app_pda(accounts.source_port, &self.program_id);
        let (packet_commitment, _) = TimeoutPacket::packet_commitment_pda(
            accounts.source_client,
            accounts.sequence,
            &self.program_id,
        );
        let (client, _) = TimeoutPacket::client_pda(accounts.source_client, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(ibc_app, false),
            AccountMeta::new(packet_commitment, false),
            AccountMeta::new_readonly(accounts.ibc_app_program, false),
            AccountMeta::new(accounts.ibc_app_state, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `add_client` instruction.
pub struct AddClientAccounts<'a> {
    pub authority: Pubkey,
    pub access_manager: Pubkey,
    pub light_client_program: Pubkey,
    pub client_id: &'a str,
}

/// Instruction constants and PDA helpers for `add_client`.
pub struct AddClient;

impl AddClient {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [97, 103, 215, 121, 86, 53, 223, 241];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn client_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", client_id.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_sequence_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client_sequence", client_id.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> AddClientBuilder<'a> {
        AddClientBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AddClientArgs {
    pub client_id: String,
    pub counterparty_info: CounterpartyInfo,
}

/// Builder for the `add_client` instruction.
pub struct AddClientBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<AddClientAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> AddClientBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: AddClientAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &AddClientArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = AddClient::router_state_pda(&self.program_id);
        let (client, _) = AddClient::client_pda(accounts.client_id, &self.program_id);
        let (client_sequence, _) =
            AddClient::client_sequence_pda(accounts.client_id, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(accounts.authority, true),
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(client, false),
            AccountMeta::new(client_sequence, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `migrate_client` instruction.
pub struct MigrateClientAccounts<'a> {
    pub authority: Pubkey,
    pub access_manager: Pubkey,
    pub client_id: &'a str,
}

/// Instruction constants and PDA helpers for `migrate_client`.
pub struct MigrateClient;

impl MigrateClient {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 5;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 190, 13, 80, 51, 174, 34, 252];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn client_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", client_id.as_bytes()], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> MigrateClientBuilder<'a> {
        MigrateClientBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct MigrateClientArgs {
    pub client_id: String,
    pub params: MigrateClientParams,
}

/// Builder for the `migrate_client` instruction.
pub struct MigrateClientBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<MigrateClientAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> MigrateClientBuilder<'a> {
    #[must_use]
    pub fn accounts(mut self, accounts: MigrateClientAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MigrateClientArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = MigrateClient::router_state_pda(&self.program_id);
        let (client, _) = MigrateClient::client_pda(accounts.client_id, &self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(accounts.authority, true),
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(client, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `upload_payload_chunk` instruction.
pub struct UploadPayloadChunkAccounts {
    pub access_manager: Pubkey,
    pub chunk: Pubkey,
    pub relayer: Pubkey,
}

/// Instruction constants and PDA helpers for `upload_payload_chunk`.
pub struct UploadPayloadChunk;

impl UploadPayloadChunk {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 6;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [191, 138, 167, 248, 208, 192, 24, 82];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> UploadPayloadChunkBuilder {
        UploadPayloadChunkBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `upload_payload_chunk` instruction.
pub struct UploadPayloadChunkBuilder {
    program_id: Pubkey,
    accounts: Option<UploadPayloadChunkAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl UploadPayloadChunkBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: UploadPayloadChunkAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgUploadChunk) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = UploadPayloadChunk::router_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(accounts.chunk, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `upload_proof_chunk` instruction.
pub struct UploadProofChunkAccounts {
    pub access_manager: Pubkey,
    pub chunk: Pubkey,
    pub relayer: Pubkey,
}

/// Instruction constants and PDA helpers for `upload_proof_chunk`.
pub struct UploadProofChunk;

impl UploadProofChunk {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 6;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [60, 215, 88, 47, 168, 107, 123, 150];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> UploadProofChunkBuilder {
        UploadProofChunkBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `upload_proof_chunk` instruction.
pub struct UploadProofChunkBuilder {
    program_id: Pubkey,
    accounts: Option<UploadProofChunkAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl UploadProofChunkBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: UploadProofChunkAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgUploadChunk) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = UploadProofChunk::router_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(accounts.chunk, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `cleanup_chunks` instruction.
pub struct CleanupChunksAccounts {
    pub access_manager: Pubkey,
    pub relayer: Pubkey,
}

/// Instruction constants and PDA helpers for `cleanup_chunks`.
pub struct CleanupChunks;

impl CleanupChunks {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [161, 232, 178, 127, 188, 117, 9, 18];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> CleanupChunksBuilder {
        CleanupChunksBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `cleanup_chunks` instruction.
pub struct CleanupChunksBuilder {
    program_id: Pubkey,
    accounts: Option<CleanupChunksAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl CleanupChunksBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: CleanupChunksAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &MsgCleanupChunks) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = CleanupChunks::router_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new_readonly(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new(accounts.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_access_manager` instruction.
pub struct SetAccessManagerAccounts {
    pub access_manager: Pubkey,
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_access_manager`.
pub struct SetAccessManager;

impl SetAccessManager {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 209, 134, 89, 195, 69, 35, 122];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetAccessManagerBuilder {
        SetAccessManagerBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetAccessManagerArgs {
    pub new_access_manager: Pubkey,
}

/// Builder for the `set_access_manager` instruction.
pub struct SetAccessManagerBuilder {
    program_id: Pubkey,
    accounts: Option<SetAccessManagerAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetAccessManagerBuilder {
    #[must_use]
    pub fn accounts(mut self, accounts: SetAccessManagerAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetAccessManagerArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (router_state, _) = SetAccessManager::router_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(router_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}
