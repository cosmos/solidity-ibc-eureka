// AUTO-GENERATED from ics26_router IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `initialize`.
pub struct Initialize {
    program_id: Pubkey,
    router_state: Pubkey,
    payer: Pubkey,
}

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: InitializeAccounts, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        Self {
            program_id: *program_id,
            router_state,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.router_state, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub access_manager: Pubkey,
}

impl Initialize {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &InitializeArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `add_ibc_app` instruction.
pub struct AddIbcAppAccounts<'a> {
    pub access_manager: Pubkey,
    pub app_program: Pubkey,
    pub payer: Pubkey,
    pub authority: Pubkey,
    pub port_id: &'a str,
}

/// Resolved instruction accounts for `add_ibc_app`.
pub struct AddIbcApp {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    ibc_app: Pubkey,
    app_program: Pubkey,
    payer: Pubkey,
    authority: Pubkey,
}

impl AddIbcApp {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [233, 201, 201, 149, 2, 13, 134, 27];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(port_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", port_id.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: AddIbcAppAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (ibc_app, _) = Self::ibc_app_pda(accounts.port_id, program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            ibc_app,
            app_program: accounts.app_program,
            payer: accounts.payer,
            authority: accounts.authority,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.ibc_app, false),
            AccountMeta::new_readonly(self.app_program, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(self.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AddIbcAppArgs {
    pub port_id: String,
}

impl AddIbcApp {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &AddIbcAppArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `send_packet` instruction.
pub struct SendPacketAccounts<'a> {
    pub packet_commitment: Pubkey,
    pub app_signer: Pubkey,
    pub payer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a str,
    pub source_client: &'a str,
}

/// Resolved instruction accounts for `send_packet`.
pub struct SendPacket {
    program_id: Pubkey,
    router_state: Pubkey,
    ibc_app: Pubkey,
    client_sequence: Pubkey,
    packet_commitment: Pubkey,
    app_signer: Pubkey,
    payer: Pubkey,
    client: Pubkey,
    light_client_program: Pubkey,
    client_state: Pubkey,
    consensus_state: Pubkey,
}

impl SendPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 11;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [242, 7, 23, 143, 124, 157, 42, 102];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_sequence_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client_sequence", source_client.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SendPacketAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (ibc_app, _) = Self::ibc_app_pda(accounts.source_port, program_id);
        let (client_sequence, _) = Self::client_sequence_pda(accounts.source_client, program_id);
        let (client, _) = Self::client_pda(accounts.source_client, program_id);
        Self {
            program_id: *program_id,
            router_state,
            ibc_app,
            client_sequence,
            packet_commitment: accounts.packet_commitment,
            app_signer: accounts.app_signer,
            payer: accounts.payer,
            client,
            light_client_program: accounts.light_client_program,
            client_state: accounts.client_state,
            consensus_state: accounts.consensus_state,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.ibc_app, false),
            AccountMeta::new(self.client_sequence, false),
            AccountMeta::new(self.packet_commitment, false),
            AccountMeta::new_readonly(self.app_signer, true),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(self.client, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgSendPacket,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `recv_packet` instruction.
pub struct RecvPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub dest_port: &'a [u8],
    pub dest_client: &'a str,
    pub sequence: u64,
}

/// Resolved instruction accounts for `recv_packet`.
pub struct RecvPacket {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    ibc_app: Pubkey,
    packet_receipt: Pubkey,
    packet_ack: Pubkey,
    ibc_app_program: Pubkey,
    ibc_app_state: Pubkey,
    relayer: Pubkey,
    client: Pubkey,
    light_client_program: Pubkey,
    client_state: Pubkey,
    consensus_state: Pubkey,
}

impl RecvPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 14;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [130, 14, 240, 161, 35, 63, 45, 71];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(dest_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", dest_port], program_id)
    }

    #[must_use]
    pub fn packet_receipt_pda(
        dest_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_receipt",
                dest_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn packet_ack_pda(dest_client: &str, sequence: u64, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_ack",
                dest_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(dest_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", dest_client.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: RecvPacketAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (ibc_app, _) = Self::ibc_app_pda(accounts.dest_port, program_id);
        let (packet_receipt, _) =
            Self::packet_receipt_pda(accounts.dest_client, accounts.sequence, program_id);
        let (packet_ack, _) =
            Self::packet_ack_pda(accounts.dest_client, accounts.sequence, program_id);
        let (client, _) = Self::client_pda(accounts.dest_client, program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            ibc_app,
            packet_receipt,
            packet_ack,
            ibc_app_program: accounts.ibc_app_program,
            ibc_app_state: accounts.ibc_app_state,
            relayer: accounts.relayer,
            client,
            light_client_program: accounts.light_client_program,
            client_state: accounts.client_state,
            consensus_state: accounts.consensus_state,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(self.ibc_app, false),
            AccountMeta::new(self.packet_receipt, false),
            AccountMeta::new(self.packet_ack, false),
            AccountMeta::new_readonly(self.ibc_app_program, false),
            AccountMeta::new(self.ibc_app_state, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(self.client, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgRecvPacket,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `ack_packet` instruction.
pub struct AckPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a [u8],
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Resolved instruction accounts for `ack_packet`.
pub struct AckPacket {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    ibc_app: Pubkey,
    packet_commitment: Pubkey,
    ibc_app_program: Pubkey,
    ibc_app_state: Pubkey,
    relayer: Pubkey,
    client: Pubkey,
    light_client_program: Pubkey,
    client_state: Pubkey,
    consensus_state: Pubkey,
}

impl AckPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 13;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [43, 194, 45, 54, 2, 40, 211, 228];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port], program_id)
    }

    #[must_use]
    pub fn packet_commitment_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_commitment",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: AckPacketAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (ibc_app, _) = Self::ibc_app_pda(accounts.source_port, program_id);
        let (packet_commitment, _) =
            Self::packet_commitment_pda(accounts.source_client, accounts.sequence, program_id);
        let (client, _) = Self::client_pda(accounts.source_client, program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            ibc_app,
            packet_commitment,
            ibc_app_program: accounts.ibc_app_program,
            ibc_app_state: accounts.ibc_app_state,
            relayer: accounts.relayer,
            client,
            light_client_program: accounts.light_client_program,
            client_state: accounts.client_state,
            consensus_state: accounts.consensus_state,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(self.ibc_app, false),
            AccountMeta::new(self.packet_commitment, false),
            AccountMeta::new_readonly(self.ibc_app_program, false),
            AccountMeta::new(self.ibc_app_state, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(self.client, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgAckPacket,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `timeout_packet` instruction.
pub struct TimeoutPacketAccounts<'a> {
    pub access_manager: Pubkey,
    pub ibc_app_program: Pubkey,
    pub ibc_app_state: Pubkey,
    pub relayer: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
    pub source_port: &'a [u8],
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Resolved instruction accounts for `timeout_packet`.
pub struct TimeoutPacket {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    ibc_app: Pubkey,
    packet_commitment: Pubkey,
    ibc_app_program: Pubkey,
    ibc_app_state: Pubkey,
    relayer: Pubkey,
    client: Pubkey,
    light_client_program: Pubkey,
    client_state: Pubkey,
    consensus_state: Pubkey,
}

impl TimeoutPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 13;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [224, 56, 82, 83, 77, 13, 120, 103];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn ibc_app_pda(source_port: &[u8], program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"ibc_app", source_port], program_id)
    }

    #[must_use]
    pub fn packet_commitment_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"packet_commitment",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    #[must_use]
    pub fn client_pda(source_client: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", source_client.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: TimeoutPacketAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (ibc_app, _) = Self::ibc_app_pda(accounts.source_port, program_id);
        let (packet_commitment, _) =
            Self::packet_commitment_pda(accounts.source_client, accounts.sequence, program_id);
        let (client, _) = Self::client_pda(accounts.source_client, program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            ibc_app,
            packet_commitment,
            ibc_app_program: accounts.ibc_app_program,
            ibc_app_state: accounts.ibc_app_state,
            relayer: accounts.relayer,
            client,
            light_client_program: accounts.light_client_program,
            client_state: accounts.client_state,
            consensus_state: accounts.consensus_state,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(self.ibc_app, false),
            AccountMeta::new(self.packet_commitment, false),
            AccountMeta::new_readonly(self.ibc_app_program, false),
            AccountMeta::new(self.ibc_app_state, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(self.client, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgTimeoutPacket,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `add_client` instruction.
pub struct AddClientAccounts<'a> {
    pub authority: Pubkey,
    pub access_manager: Pubkey,
    pub light_client_program: Pubkey,
    pub client_id: &'a str,
}

/// Resolved instruction accounts for `add_client`.
pub struct AddClient {
    program_id: Pubkey,
    authority: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    client: Pubkey,
    client_sequence: Pubkey,
    light_client_program: Pubkey,
}

impl AddClient {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 8;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [97, 103, 215, 121, 86, 53, 223, 241];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn client_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", client_id.as_bytes()], program_id)
    }

    #[must_use]
    pub fn client_sequence_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client_sequence", client_id.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: AddClientAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (client, _) = Self::client_pda(accounts.client_id, program_id);
        let (client_sequence, _) = Self::client_sequence_pda(accounts.client_id, program_id);
        Self {
            program_id: *program_id,
            authority: accounts.authority,
            router_state,
            access_manager: accounts.access_manager,
            client,
            client_sequence,
            light_client_program: accounts.light_client_program,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.authority, true),
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.client, false),
            AccountMeta::new(self.client_sequence, false),
            AccountMeta::new_readonly(self.light_client_program, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct AddClientArgs {
    pub client_id: String,
    pub counterparty_info: CounterpartyInfo,
}

impl AddClient {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &AddClientArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `migrate_client` instruction.
pub struct MigrateClientAccounts<'a> {
    pub authority: Pubkey,
    pub access_manager: Pubkey,
    pub client_id: &'a str,
}

/// Resolved instruction accounts for `migrate_client`.
pub struct MigrateClient {
    program_id: Pubkey,
    authority: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    client: Pubkey,
}

impl MigrateClient {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 5;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 190, 13, 80, 51, 174, 34, 252];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    #[must_use]
    pub fn client_pda(client_id: &str, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client", client_id.as_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: MigrateClientAccounts<'_>, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        let (client, _) = Self::client_pda(accounts.client_id, program_id);
        Self {
            program_id: *program_id,
            authority: accounts.authority,
            router_state,
            access_manager: accounts.access_manager,
            client,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.authority, true),
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.client, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct MigrateClientArgs {
    pub client_id: String,
    pub params: MigrateClientParams,
}

impl MigrateClient {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MigrateClientArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `upload_payload_chunk` instruction.
pub struct UploadPayloadChunkAccounts {
    pub access_manager: Pubkey,
    pub chunk: Pubkey,
    pub relayer: Pubkey,
}

/// Resolved instruction accounts for `upload_payload_chunk`.
pub struct UploadPayloadChunk {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    chunk: Pubkey,
    relayer: Pubkey,
}

impl UploadPayloadChunk {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 6;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [191, 138, 167, 248, 208, 192, 24, 82];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: UploadPayloadChunkAccounts, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            chunk: accounts.chunk,
            relayer: accounts.relayer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.chunk, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgUploadChunk,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `upload_proof_chunk` instruction.
pub struct UploadProofChunkAccounts {
    pub access_manager: Pubkey,
    pub chunk: Pubkey,
    pub relayer: Pubkey,
}

/// Resolved instruction accounts for `upload_proof_chunk`.
pub struct UploadProofChunk {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    chunk: Pubkey,
    relayer: Pubkey,
}

impl UploadProofChunk {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 6;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [60, 215, 88, 47, 168, 107, 123, 150];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: UploadProofChunkAccounts, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            chunk: accounts.chunk,
            relayer: accounts.relayer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.chunk, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgUploadChunk,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `cleanup_chunks` instruction.
pub struct CleanupChunksAccounts {
    pub access_manager: Pubkey,
    pub relayer: Pubkey,
}

/// Resolved instruction accounts for `cleanup_chunks`.
pub struct CleanupChunks {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    relayer: Pubkey,
}

impl CleanupChunks {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [161, 232, 178, 127, 188, 117, 9, 18];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: CleanupChunksAccounts, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            relayer: accounts.relayer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new(self.relayer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &MsgCleanupChunks,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_access_manager` instruction.
pub struct SetAccessManagerAccounts {
    pub access_manager: Pubkey,
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_access_manager`.
pub struct SetAccessManager {
    program_id: Pubkey,
    router_state: Pubkey,
    access_manager: Pubkey,
    admin: Pubkey,
}

impl SetAccessManager {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 209, 134, 89, 195, 69, 35, 122];

    #[must_use]
    pub fn router_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"router_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetAccessManagerAccounts, program_id: &Pubkey) -> Self {
        let (router_state, _) = Self::router_state_pda(program_id);
        Self {
            program_id: *program_id,
            router_state,
            access_manager: accounts.access_manager,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.router_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetAccessManagerArgs {
    pub new_access_manager: Pubkey,
}

impl SetAccessManager {
    /// Builds a complete [`Instruction`] with discriminator, typed args and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args: &SetAccessManagerArgs,
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}
