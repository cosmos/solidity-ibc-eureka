// AUTO-GENERATED from attestation IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Resolved instruction accounts for `initialize`.
pub struct Initialize {
    program_id: Pubkey,
    client_state: Pubkey,
    app_state: Pubkey,
    payer: Pubkey,
}

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn client_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client"], program_id)
    }

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: InitializeAccounts, program_id: &Pubkey) -> Self {
        let (client_state, _) = Self::client_state_pda(program_id);
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            client_state,
            app_state,
            payer: accounts.payer,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.client_state, false),
            AccountMeta::new(self.app_state, false),
            AccountMeta::new(self.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `set_access_manager` instruction.
pub struct SetAccessManagerAccounts {
    pub access_manager: Pubkey,
    pub admin: Pubkey,
}

/// Resolved instruction accounts for `set_access_manager`.
pub struct SetAccessManager {
    program_id: Pubkey,
    app_state: Pubkey,
    access_manager: Pubkey,
    admin: Pubkey,
}

impl SetAccessManager {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 209, 134, 89, 195, 69, 35, 122];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: SetAccessManagerAccounts, program_id: &Pubkey) -> Self {
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            app_state,
            access_manager: accounts.access_manager,
            admin: accounts.admin,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.app_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(self.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `verify_membership` instruction.
pub struct VerifyMembershipAccounts {
    pub height: u64,
}

/// Resolved instruction accounts for `verify_membership`.
pub struct VerifyMembership {
    program_id: Pubkey,
    client_state: Pubkey,
    consensus_state_at_height: Pubkey,
}

impl VerifyMembership {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 2;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [101, 53, 78, 0, 103, 151, 236, 209];

    #[must_use]
    pub fn client_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client"], program_id)
    }

    #[must_use]
    pub fn consensus_state_at_height_pda(height: u64, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"consensus_state", &height.to_le_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: VerifyMembershipAccounts, program_id: &Pubkey) -> Self {
        let (client_state, _) = Self::client_state_pda(program_id);
        let (consensus_state_at_height, _) =
            Self::consensus_state_at_height_pda(accounts.height, program_id);
        Self {
            program_id: *program_id,
            client_state,
            consensus_state_at_height,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state_at_height, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `verify_non_membership` instruction.
pub struct VerifyNonMembershipAccounts {
    pub height: u64,
}

/// Resolved instruction accounts for `verify_non_membership`.
pub struct VerifyNonMembership {
    program_id: Pubkey,
    client_state: Pubkey,
    consensus_state_at_height: Pubkey,
}

impl VerifyNonMembership {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 2;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [231, 161, 86, 239, 111, 236, 14, 74];

    #[must_use]
    pub fn client_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client"], program_id)
    }

    #[must_use]
    pub fn consensus_state_at_height_pda(height: u64, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"consensus_state", &height.to_le_bytes()], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: VerifyNonMembershipAccounts, program_id: &Pubkey) -> Self {
        let (client_state, _) = Self::client_state_pda(program_id);
        let (consensus_state_at_height, _) =
            Self::consensus_state_at_height_pda(accounts.height, program_id);
        Self {
            program_id: *program_id,
            client_state,
            consensus_state_at_height,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state_at_height, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `update_client` instruction.
pub struct UpdateClientAccounts {
    pub access_manager: Pubkey,
    pub submitter: Pubkey,
    pub new_height: u64,
}

/// Resolved instruction accounts for `update_client`.
pub struct UpdateClient {
    program_id: Pubkey,
    client_state: Pubkey,
    consensus_state_store: Pubkey,
    app_state: Pubkey,
    access_manager: Pubkey,
    submitter: Pubkey,
}

impl UpdateClient {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 7;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [184, 89, 17, 76, 97, 57, 165, 10];

    #[must_use]
    pub fn client_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client"], program_id)
    }

    #[must_use]
    pub fn consensus_state_store_pda(new_height: u64, program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"consensus_state", &new_height.to_le_bytes()], program_id)
    }

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: UpdateClientAccounts, program_id: &Pubkey) -> Self {
        let (client_state, _) = Self::client_state_pda(program_id);
        let (consensus_state_store, _) =
            Self::consensus_state_store_pda(accounts.new_height, program_id);
        let (app_state, _) = Self::app_state_pda(program_id);
        Self {
            program_id: *program_id,
            client_state,
            consensus_state_store,
            app_state,
            access_manager: accounts.access_manager,
            submitter: accounts.submitter,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new(self.client_state, false),
            AccountMeta::new(self.consensus_state_store, false),
            AccountMeta::new_readonly(self.app_state, false),
            AccountMeta::new_readonly(self.access_manager, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new(self.submitter, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}

/// Input accounts for the `client_status` instruction.
pub struct ClientStatusAccounts {
    pub consensus_state: Pubkey,
}

/// Resolved instruction accounts for `client_status`.
pub struct ClientStatus {
    program_id: Pubkey,
    client_state: Pubkey,
    consensus_state: Pubkey,
}

impl ClientStatus {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 2;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [75, 93, 126, 21, 10, 112, 109, 139];

    #[must_use]
    pub fn client_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"client"], program_id)
    }

    /// Creates a new instruction builder, auto-deriving PDA accounts.
    #[must_use]
    pub fn new(accounts: ClientStatusAccounts, program_id: &Pubkey) -> Self {
        let (client_state, _) = Self::client_state_pda(program_id);
        Self {
            program_id: *program_id,
            client_state,
            consensus_state: accounts.consensus_state,
        }
    }

    /// Returns account metas in the order expected by the program.
    #[must_use]
    pub fn to_account_metas(&self) -> Vec<AccountMeta> {
        vec![
            AccountMeta::new_readonly(self.client_state, false),
            AccountMeta::new_readonly(self.consensus_state, false),
        ]
    }

    /// Builds a complete [`Instruction`] with discriminator, args data and remaining accounts.
    #[must_use]
    pub fn build_instruction(
        self,
        args_data: &[u8],
        remaining_accounts: impl IntoIterator<Item = AccountMeta>,
    ) -> Instruction {
        let mut accounts = self.to_account_metas();
        accounts.extend(remaining_accounts);
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(args_data);
        Instruction {
            program_id: self.program_id,
            accounts,
            data,
        }
    }
}
