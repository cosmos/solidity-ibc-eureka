// AUTO-GENERATED from ics27_gmp IDL - do not edit
// Generated by build.rs from Anchor IDL files
//
// These structs provide typed instruction account builders that match
// the exact account ordering defined in the Anchor program.

#![allow(unused_imports)]

use super::accounts::*;
use super::types::*;
use anchor_lang::prelude::borsh::{self, BorshDeserialize, BorshSerialize};
use anchor_lang::solana_program::instruction::{AccountMeta, Instruction};
use anchor_lang::solana_program::pubkey::Pubkey;

/// Input accounts for the `initialize` instruction.
pub struct InitializeAccounts {
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `initialize`.
pub struct Initialize;

impl Initialize {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 3;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [175, 175, 109, 31, 13, 152, 155, 237];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> InitializeBuilder {
        InitializeBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct InitializeArgs {
    pub access_manager: Pubkey,
}

/// Builder for the `initialize` instruction.
pub struct InitializeBuilder {
    program_id: Pubkey,
    accounts: Option<InitializeAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl InitializeBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: InitializeAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &InitializeArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = Initialize::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `send_call` instruction.
pub struct SendCallAccounts {
    pub sender: Pubkey,
    pub payer: Pubkey,
    pub router_state: Pubkey,
    pub client_sequence: Pubkey,
    pub packet_commitment: Pubkey,
    pub ibc_app: Pubkey,
    pub client: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
}

/// Instruction constants and PDA helpers for `send_call`.
pub struct SendCall;

impl SendCall {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 14;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [254, 95, 190, 68, 194, 140, 28, 103];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SendCallBuilder {
        SendCallBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `send_call` instruction.
pub struct SendCallBuilder {
    program_id: Pubkey,
    accounts: Option<SendCallAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SendCallBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SendCallAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SendCallMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SendCall::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.sender, true),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx"),
                false,
            ),
            AccountMeta::new_readonly(accounts.router_state, false),
            AccountMeta::new(accounts.client_sequence, false),
            AccountMeta::new(accounts.packet_commitment, false),
            AccountMeta::new_readonly(accounts.ibc_app, false),
            AccountMeta::new_readonly(accounts.client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `send_call_cpi` instruction.
pub struct SendCallCpiAccounts {
    pub payer: Pubkey,
    pub router_state: Pubkey,
    pub client_sequence: Pubkey,
    pub packet_commitment: Pubkey,
    pub ibc_app: Pubkey,
    pub client: Pubkey,
    pub light_client_program: Pubkey,
    pub client_state: Pubkey,
    pub consensus_state: Pubkey,
}

/// Instruction constants and PDA helpers for `send_call_cpi`.
pub struct SendCallCpi;

impl SendCallCpi {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 13;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [97, 64, 45, 56, 8, 199, 98, 206];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SendCallCpiBuilder {
        SendCallCpiBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `send_call_cpi` instruction.
pub struct SendCallCpiBuilder {
    program_id: Pubkey,
    accounts: Option<SendCallCpiAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SendCallCpiBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SendCallCpiAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SendCallMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SendCallCpi::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(
                Pubkey::from_str_const("FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx"),
                false,
            ),
            AccountMeta::new_readonly(accounts.router_state, false),
            AccountMeta::new(accounts.client_sequence, false),
            AccountMeta::new(accounts.packet_commitment, false),
            AccountMeta::new_readonly(accounts.ibc_app, false),
            AccountMeta::new_readonly(accounts.client, false),
            AccountMeta::new_readonly(accounts.light_client_program, false),
            AccountMeta::new_readonly(accounts.client_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new_readonly(accounts.consensus_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `on_recv_packet` instruction.
pub struct OnRecvPacketAccounts {
    pub payer: Pubkey,
}

/// Instruction constants and PDA helpers for `on_recv_packet`.
pub struct OnRecvPacket;

impl OnRecvPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [153, 133, 78, 48, 156, 128, 229, 104];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> OnRecvPacketBuilder {
        OnRecvPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `on_recv_packet` instruction.
pub struct OnRecvPacketBuilder {
    program_id: Pubkey,
    accounts: Option<OnRecvPacketAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl OnRecvPacketBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: OnRecvPacketAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &OnRecvPacketMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = OnRecvPacket::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `on_acknowledgement_packet` instruction.
pub struct OnAcknowledgementPacketAccounts<'a> {
    pub payer: Pubkey,
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Instruction constants and PDA helpers for `on_acknowledgement_packet`.
pub struct OnAcknowledgementPacket;

impl OnAcknowledgementPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 5;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [1, 142, 48, 169, 216, 66, 198, 31];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    #[must_use]
    pub fn result_account_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"gmp_result",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> OnAcknowledgementPacketBuilder<'a> {
        OnAcknowledgementPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `on_acknowledgement_packet` instruction.
pub struct OnAcknowledgementPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<OnAcknowledgementPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> OnAcknowledgementPacketBuilder<'a> {
    #[must_use]
    pub const fn accounts(mut self, accounts: OnAcknowledgementPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &OnAcknowledgementPacketMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = OnAcknowledgementPacket::app_state_pda(&self.program_id);
        let (result_account, _) = OnAcknowledgementPacket::result_account_pda(
            accounts.source_client,
            accounts.sequence,
            &self.program_id,
        );
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new(result_account, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `on_timeout_packet` instruction.
pub struct OnTimeoutPacketAccounts<'a> {
    pub payer: Pubkey,
    pub source_client: &'a str,
    pub sequence: u64,
}

/// Instruction constants and PDA helpers for `on_timeout_packet`.
pub struct OnTimeoutPacket;

impl OnTimeoutPacket {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 5;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [152, 10, 26, 185, 36, 193, 95, 76];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    #[must_use]
    pub fn result_account_pda(
        source_client: &str,
        sequence: u64,
        program_id: &Pubkey,
    ) -> (Pubkey, u8) {
        Pubkey::find_program_address(
            &[
                b"gmp_result",
                source_client.as_bytes(),
                &sequence.to_le_bytes(),
            ],
            program_id,
        )
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder<'a>(program_id: &Pubkey) -> OnTimeoutPacketBuilder<'a> {
        OnTimeoutPacketBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `on_timeout_packet` instruction.
pub struct OnTimeoutPacketBuilder<'a> {
    program_id: Pubkey,
    accounts: Option<OnTimeoutPacketAccounts<'a>>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl<'a> OnTimeoutPacketBuilder<'a> {
    #[must_use]
    pub const fn accounts(mut self, accounts: OnTimeoutPacketAccounts<'a>) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &OnTimeoutPacketMsg) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = OnTimeoutPacket::app_state_pda(&self.program_id);
        let (result_account, _) = OnTimeoutPacket::result_account_pda(
            accounts.source_client,
            accounts.sequence,
            &self.program_id,
        );
        let mut account_metas = vec![
            AccountMeta::new_readonly(app_state, false),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
            AccountMeta::new(accounts.payer, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::system_program::ID, false),
            AccountMeta::new(result_account, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `pause_app` instruction.
pub struct PauseAppAccounts {
    pub access_manager: Pubkey,
    pub authority: Pubkey,
}

/// Instruction constants and PDA helpers for `pause_app`.
pub struct PauseApp;

impl PauseApp {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [142, 191, 211, 112, 238, 129, 131, 66];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> PauseAppBuilder {
        PauseAppBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `pause_app` instruction.
pub struct PauseAppBuilder {
    program_id: Pubkey,
    accounts: Option<PauseAppAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl PauseAppBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: PauseAppAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = PauseApp::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(accounts.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `unpause_app` instruction.
pub struct UnpauseAppAccounts {
    pub access_manager: Pubkey,
    pub authority: Pubkey,
}

/// Instruction constants and PDA helpers for `unpause_app`.
pub struct UnpauseApp;

impl UnpauseApp {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [73, 253, 89, 192, 87, 42, 245, 3];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> UnpauseAppBuilder {
        UnpauseAppBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

/// Builder for the `unpause_app` instruction.
pub struct UnpauseAppBuilder {
    program_id: Pubkey,
    accounts: Option<UnpauseAppAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl UnpauseAppBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: UnpauseAppAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = UnpauseApp::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(accounts.authority, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}

/// Input accounts for the `set_access_manager` instruction.
pub struct SetAccessManagerAccounts {
    pub access_manager: Pubkey,
    pub admin: Pubkey,
}

/// Instruction constants and PDA helpers for `set_access_manager`.
pub struct SetAccessManager;

impl SetAccessManager {
    /// Total number of accounts (including fixed-address accounts).
    pub const COUNT: usize = 4;

    /// Anchor instruction discriminator.
    pub const DISCRIMINATOR: [u8; 8] = [95, 209, 134, 89, 195, 69, 35, 122];

    #[must_use]
    pub fn app_state_pda(program_id: &Pubkey) -> (Pubkey, u8) {
        Pubkey::find_program_address(&[b"app_state"], program_id)
    }

    /// Creates a builder for this instruction.
    #[must_use]
    pub fn builder(program_id: &Pubkey) -> SetAccessManagerBuilder {
        SetAccessManagerBuilder {
            program_id: *program_id,
            accounts: None,
            args_data: Self::DISCRIMINATOR.to_vec(),
            remaining_accounts: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]
pub struct SetAccessManagerArgs {
    pub new_access_manager: Pubkey,
}

/// Builder for the `set_access_manager` instruction.
pub struct SetAccessManagerBuilder {
    program_id: Pubkey,
    accounts: Option<SetAccessManagerAccounts>,
    args_data: Vec<u8>,
    remaining_accounts: Vec<AccountMeta>,
}

impl SetAccessManagerBuilder {
    #[must_use]
    pub const fn accounts(mut self, accounts: SetAccessManagerAccounts) -> Self {
        self.accounts = Some(accounts);
        self
    }

    #[must_use]
    pub fn args(mut self, args: &SetAccessManagerArgs) -> Self {
        self.args_data
            .extend_from_slice(&borsh::to_vec(args).expect("borsh serialize"));
        self
    }

    #[must_use]
    pub fn remaining_accounts(mut self, accounts: impl IntoIterator<Item = AccountMeta>) -> Self {
        self.remaining_accounts.extend(accounts);
        self
    }

    /// Builds the [`Instruction`], deriving PDA accounts and serializing args.
    #[must_use]
    pub fn build(self) -> Instruction {
        let accounts = self.accounts.expect("accounts required");
        let (app_state, _) = SetAccessManager::app_state_pda(&self.program_id);
        let mut account_metas = vec![
            AccountMeta::new(app_state, false),
            AccountMeta::new_readonly(accounts.access_manager, false),
            AccountMeta::new_readonly(accounts.admin, true),
            AccountMeta::new_readonly(anchor_lang::solana_program::sysvar::instructions::ID, false),
        ];
        account_metas.extend(self.remaining_accounts);
        Instruction {
            program_id: self.program_id,
            accounts: account_metas,
            data: self.args_data,
        }
    }
}
