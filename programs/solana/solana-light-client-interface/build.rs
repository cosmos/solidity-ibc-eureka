//! Build script for generating discriminators

use sha2::{Digest as _, Sha256};
use std::env;
use std::fs;
use std::path::Path;

// NOTE: Precompute discriminators for functions so light client could be called dynamically in router
fn main() {
    let verify_membership_discm = compute_discriminator("global", "verify_membership");
    let verify_non_membership_discm = compute_discriminator("global", "verify_non_membership");

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR environment variable not set");
    let dest_path = Path::new(&out_dir).join("discriminators.rs");

    let content = format!(
        r#"// Auto-generated by build.rs
/// Standard instruction discriminators that all light clients must use
pub mod discriminators {{
    /// Discriminator for `verify_membership` instruction
    /// Computed from `sha256("global:verify_membership")`
    pub const VERIFY_MEMBERSHIP: [u8; 8] = {verify_membership_discm:?};

    /// Discriminator for `verify_non_membership` instruction
    /// Computed from `sha256("global:verify_non_membership")`
    pub const VERIFY_NON_MEMBERSHIP: [u8; 8] = {verify_non_membership_discm:?};
}}
"#
    );

    fs::write(&dest_path, content).expect("Failed to write discriminators.rs");

    println!("cargo:rerun-if-changed=build.rs");
}

/// Compute discriminator from namespace and name
fn compute_discriminator(namespace: &str, name: &str) -> [u8; 8] {
    let preimage = format!("{namespace}:{name}");
    let mut hasher = Sha256::new();
    hasher.update(preimage.as_bytes());
    let hash_result = hasher.finalize();

    let mut discriminator = [0u8; 8];
    discriminator.copy_from_slice(hash_result.get(..8).expect("Hash result too short"));
    discriminator
}
