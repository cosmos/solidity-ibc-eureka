//! Generic function and data structures for verifying
//! attested data.

use std::collections::HashSet;

use alloy_primitives::Address;
use secp256k1::{ecdsa::Signature, Message, PublicKey, Secp256k1};
use sha2::{Digest, Sha256};

use crate::{client_state::ClientState, error::IbcAttestorClientError};

// NOTE: We intentionally do not enforce low-S (EIP-2) here to match existing behavior
// and avoid rejecting valid signatures generated by test utilities.

/// Verifies the cryptographic validity of the attestation data.
///
/// Fails if:
/// - Signatures or pubkeys are not unique
/// - Too few signatures or pubkeys are submitted
/// - The number of signatures and pubkeys does not match
/// - The attestations cannot be verified
/// - A rogue public key is submitted
#[allow(clippy::module_name_repetitions)]
pub(crate) fn verify_attestation(
    client_state: &ClientState,
    attestation_data: &[u8],
    signatures: &[Vec<u8>],
    public_keys: &[Vec<u8>],
) -> Result<(), IbcAttestorClientError> {
    if signatures.len() != public_keys.len() {
        return Err(IbcAttestorClientError::InvalidAttestedData { reason: "number of signatures must equal number of public_keys".into() });
    }
    if signatures.len() < client_state.min_required_sigs as usize {
        return Err(IbcAttestorClientError::InvalidAttestedData { reason: "too few signatures provided".into() });
    }

    // Pre-validate public keys: must correspond to authorized attestors and be unique
    let mut seen_signers: HashSet<Address> = HashSet::new();
    let secp = Secp256k1::new();
    for pk_bytes in public_keys.iter() {
        let pk = PublicKey::from_slice(pk_bytes).map_err(|_| IbcAttestorClientError::InvalidSignature)?;
        let uncompressed = pk.serialize_uncompressed();
        let addr = Address::from_raw_public_key(&uncompressed[1..]);
        if !client_state.attestors.iter().any(|a| Address::from_slice(a) == addr) {
            return Err(IbcAttestorClientError::UnknownSigner { address: addr.into_array() });
        }
        if !seen_signers.insert(addr) {
            return Err(IbcAttestorClientError::DuplicateSigner { address: addr.into_array() });
        }
    }

    // sha256(attestation_data)
    let mut hasher = Sha256::new();
    hasher.update(attestation_data);
    let digest = hasher.finalize();
    let msg = Message::from_digest_slice(&digest).map_err(|_| IbcAttestorClientError::InvalidSignature)?;

    let mut seen_sigs: HashSet<Vec<u8>> = HashSet::new();

    for (sig_bytes, pk_bytes) in signatures.iter().zip(public_keys.iter()) {
        if sig_bytes.len() != 64 && sig_bytes.len() != 65 {
            return Err(IbcAttestorClientError::InvalidSignature);
        }
        // Reject duplicate signatures
        if !seen_sigs.insert(sig_bytes.clone()) {
            return Err(IbcAttestorClientError::InvalidAttestedData { reason: "duplicate signature provided".into() });
        }

        // Parse public key
        let pk = PublicKey::from_slice(pk_bytes).map_err(|_| IbcAttestorClientError::InvalidSignature)?;

        // Parse signature (accept 64-byte compact, or 65-byte r||s||v by dropping v)
        let compact: &[u8] = if sig_bytes.len() == 65 { &sig_bytes[..64] } else { &sig_bytes[..] };
        let sig = Signature::from_compact(compact).map_err(|_| IbcAttestorClientError::InvalidSignature)?;

        // Verify signature
        if secp.verify_ecdsa(&msg, &sig, &pk).is_err() {
            return Err(IbcAttestorClientError::InvalidSignature);
        }
    }

    Ok(())
}
