// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ift

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Account schema version
type Ics27GmpStateAccountVersion binary.BorshEnum

const (
	Ics27GmpStateAccountVersion_V1 Ics27GmpStateAccountVersion = iota
)

func (value Ics27GmpStateAccountVersion) String() string {
	switch value {
	case Ics27GmpStateAccountVersion_V1:
		return "V1"
	default:
		return ""
	}
}

// Stores the result of a GMP call (acknowledgement or timeout) for sender queries.
//
// This account is created when a GMP packet is either acknowledged or times out,
// allowing the original sender to query the outcome of their cross-chain call.
//
// # PDA Seeds
// `["gmp_result", source_client, sequence (little-endian u64)]`
type Ics27GmpStateGmpCallResultAccount struct {
	// Account schema version for future upgrades.
	Version Ics27GmpStateAccountVersion `json:"version"`

	// Original sender pubkey.
	Sender solanago.PublicKey `json:"sender"`

	// IBC packet sequence number (namespaced: `base_seq * 10000 + hash(app, sender) % 10000`).
	Sequence uint64 `json:"sequence"`

	// Source client ID (light client on this chain tracking the destination).
	SourceClient string `json:"sourceClient"`

	// Destination client ID (light client on the destination chain).
	DestClient string `json:"destClient"`

	// Result status: acknowledgement (with IBC commitment) or timeout.
	Status SolanaIbcTypesIcs27CallResultStatus `json:"status"`

	// Unix timestamp (seconds) when the result was recorded.
	ResultTimestamp int64 `json:"resultTimestamp"`

	// PDA bump seed.
	Bump uint8 `json:"bump"`
}

func (obj Ics27GmpStateGmpCallResultAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `SourceClient`:
	err = encoder.Encode(obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Serialize `DestClient`:
	err = encoder.Encode(obj.DestClient)
	if err != nil {
		return errors.NewField("DestClient", err)
	}
	// Serialize `Status`:
	{
		err := EncodeSolanaIbcTypesIcs27CallResultStatus(encoder, obj.Status)
		if err != nil {
			return errors.NewField("Status", err)
		}
	}
	// Serialize `ResultTimestamp`:
	err = encoder.Encode(obj.ResultTimestamp)
	if err != nil {
		return errors.NewField("ResultTimestamp", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	return nil
}

func (obj Ics27GmpStateGmpCallResultAccount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ics27GmpStateGmpCallResultAccount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ics27GmpStateGmpCallResultAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `SourceClient`:
	err = decoder.Decode(&obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Deserialize `DestClient`:
	err = decoder.Decode(&obj.DestClient)
	if err != nil {
		return errors.NewField("DestClient", err)
	}
	// Deserialize `Status`:
	{
		var err error
		obj.Status, err = DecodeSolanaIbcTypesIcs27CallResultStatus(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `ResultTimestamp`:
	err = decoder.Decode(&obj.ResultTimestamp)
	if err != nil {
		return errors.NewField("ResultTimestamp", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	return nil
}

func (obj *Ics27GmpStateGmpCallResultAccount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ics27GmpStateGmpCallResultAccount: %w", err)
	}
	return nil
}

func UnmarshalIcs27GmpStateGmpCallResultAccount(buf []byte) (*Ics27GmpStateGmpCallResultAccount, error) {
	obj := new(Ics27GmpStateGmpCallResultAccount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when IFT is initialized for an existing SPL token
type IftEventsExistingTokenInitialized struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// Token decimals
	Decimals uint8 `json:"decimals"`

	// Previous mint authority that transferred ownership
	PreviousAuthority solanago.PublicKey `json:"previousAuthority"`

	// Access manager program
	AccessManager solanago.PublicKey `json:"accessManager"`

	// GMP program for cross-chain calls
	GmpProgram solanago.PublicKey `json:"gmpProgram"`

	// Initialization timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsExistingTokenInitialized) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `Decimals`:
	err = encoder.Encode(obj.Decimals)
	if err != nil {
		return errors.NewField("Decimals", err)
	}
	// Serialize `PreviousAuthority`:
	err = encoder.Encode(obj.PreviousAuthority)
	if err != nil {
		return errors.NewField("PreviousAuthority", err)
	}
	// Serialize `AccessManager`:
	err = encoder.Encode(obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Serialize `GmpProgram`:
	err = encoder.Encode(obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsExistingTokenInitialized) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsExistingTokenInitialized: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsExistingTokenInitialized) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `Decimals`:
	err = decoder.Decode(&obj.Decimals)
	if err != nil {
		return errors.NewField("Decimals", err)
	}
	// Deserialize `PreviousAuthority`:
	err = decoder.Decode(&obj.PreviousAuthority)
	if err != nil {
		return errors.NewField("PreviousAuthority", err)
	}
	// Deserialize `AccessManager`:
	err = decoder.Decode(&obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Deserialize `GmpProgram`:
	err = decoder.Decode(&obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsExistingTokenInitialized) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsExistingTokenInitialized: %w", err)
	}
	return nil
}

func UnmarshalIftEventsExistingTokenInitialized(buf []byte) (*IftEventsExistingTokenInitialized, error) {
	obj := new(IftEventsExistingTokenInitialized)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when an IFT bridge is registered
type IftEventsIftBridgeRegistered struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Counterparty IFT contract address
	CounterpartyIftAddress string `json:"counterpartyIftAddress"`

	// Chain-specific options
	ChainOptions IftStateChainOptions `json:"chainOptions"`

	// Registration timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsIftBridgeRegistered) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `CounterpartyIftAddress`:
	err = encoder.Encode(obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Serialize `ChainOptions`:
	{
		err := EncodeIftStateChainOptions(encoder, obj.ChainOptions)
		if err != nil {
			return errors.NewField("ChainOptions", err)
		}
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsIftBridgeRegistered) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftBridgeRegistered: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftBridgeRegistered) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `CounterpartyIftAddress`:
	err = decoder.Decode(&obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Deserialize `ChainOptions`:
	{
		var err error
		obj.ChainOptions, err = DecodeIftStateChainOptions(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsIftBridgeRegistered) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftBridgeRegistered: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftBridgeRegistered(buf []byte) (*IftEventsIftBridgeRegistered, error) {
	obj := new(IftEventsIftBridgeRegistered)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when an IFT bridge is removed
type IftEventsIftBridgeRemoved struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Removal timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsIftBridgeRemoved) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsIftBridgeRemoved) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftBridgeRemoved: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftBridgeRemoved) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsIftBridgeRemoved) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftBridgeRemoved: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftBridgeRemoved(buf []byte) (*IftEventsIftBridgeRemoved, error) {
	obj := new(IftEventsIftBridgeRemoved)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when tokens are minted from a cross-chain transfer
type IftEventsIftMintReceived struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Receiver pubkey
	Receiver solanago.PublicKey `json:"receiver"`

	// Amount minted
	Amount uint64 `json:"amount"`

	// GMP account that authorized the mint
	GmpAccount solanago.PublicKey `json:"gmpAccount"`

	// Mint timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsIftMintReceived) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `GmpAccount`:
	err = encoder.Encode(obj.GmpAccount)
	if err != nil {
		return errors.NewField("GmpAccount", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsIftMintReceived) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftMintReceived: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftMintReceived) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `GmpAccount`:
	err = decoder.Decode(&obj.GmpAccount)
	if err != nil {
		return errors.NewField("GmpAccount", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsIftMintReceived) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftMintReceived: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftMintReceived(buf []byte) (*IftEventsIftMintReceived, error) {
	obj := new(IftEventsIftMintReceived)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when an IFT transfer is completed (acknowledged)
type IftEventsIftTransferCompleted struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Original sender
	Sender solanago.PublicKey `json:"sender"`

	// Amount that was transferred
	Amount uint64 `json:"amount"`

	// Completion timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsIftTransferCompleted) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsIftTransferCompleted) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftTransferCompleted: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftTransferCompleted) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsIftTransferCompleted) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftTransferCompleted: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftTransferCompleted(buf []byte) (*IftEventsIftTransferCompleted, error) {
	obj := new(IftEventsIftTransferCompleted)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when an IFT transfer is initiated
type IftEventsIftTransferInitiated struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Sender pubkey
	Sender solanago.PublicKey `json:"sender"`

	// Receiver address on destination chain
	Receiver string `json:"receiver"`

	// Amount transferred
	Amount uint64 `json:"amount"`

	// Timeout timestamp
	TimeoutTimestamp int64 `json:"timeoutTimestamp"`
}

func (obj IftEventsIftTransferInitiated) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `TimeoutTimestamp`:
	err = encoder.Encode(obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	return nil
}

func (obj IftEventsIftTransferInitiated) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftTransferInitiated: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftTransferInitiated) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `TimeoutTimestamp`:
	err = decoder.Decode(&obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	return nil
}

func (obj *IftEventsIftTransferInitiated) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftTransferInitiated: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftTransferInitiated(buf []byte) (*IftEventsIftTransferInitiated, error) {
	obj := new(IftEventsIftTransferInitiated)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when an IFT transfer is refunded (failed or timed out)
type IftEventsIftTransferRefunded struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Original sender (refund recipient)
	Sender solanago.PublicKey `json:"sender"`

	// Amount refunded
	Amount uint64 `json:"amount"`

	// Reason for refund
	Reason IftEventsRefundReason `json:"reason"`

	// Refund timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsIftTransferRefunded) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `Reason`:
	err = encoder.Encode(obj.Reason)
	if err != nil {
		return errors.NewField("Reason", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsIftTransferRefunded) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsIftTransferRefunded: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsIftTransferRefunded) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `Reason`:
	err = decoder.Decode(&obj.Reason)
	if err != nil {
		return errors.NewField("Reason", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsIftTransferRefunded) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsIftTransferRefunded: %w", err)
	}
	return nil
}

func UnmarshalIftEventsIftTransferRefunded(buf []byte) (*IftEventsIftTransferRefunded, error) {
	obj := new(IftEventsIftTransferRefunded)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when mint authority is revoked and transferred back
type IftEventsMintAuthorityRevoked struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// New mint authority that received ownership
	NewAuthority solanago.PublicKey `json:"newAuthority"`

	// Revocation timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsMintAuthorityRevoked) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `NewAuthority`:
	err = encoder.Encode(obj.NewAuthority)
	if err != nil {
		return errors.NewField("NewAuthority", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsMintAuthorityRevoked) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsMintAuthorityRevoked: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsMintAuthorityRevoked) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `NewAuthority`:
	err = decoder.Decode(&obj.NewAuthority)
	if err != nil {
		return errors.NewField("NewAuthority", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsMintAuthorityRevoked) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsMintAuthorityRevoked: %w", err)
	}
	return nil
}

func UnmarshalIftEventsMintAuthorityRevoked(buf []byte) (*IftEventsMintAuthorityRevoked, error) {
	obj := new(IftEventsMintAuthorityRevoked)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Reason for transfer refund
type IftEventsRefundReason binary.BorshEnum

const (
	IftEventsRefundReason_Timeout IftEventsRefundReason = iota
	IftEventsRefundReason_Failed
)

func (value IftEventsRefundReason) String() string {
	switch value {
	case IftEventsRefundReason_Timeout:
		return "Timeout"
	case IftEventsRefundReason_Failed:
		return "Failed"
	default:
		return ""
	}
}

// Event emitted when a new SPL token is created for IFT
type IftEventsSplTokenCreated struct {
	// SPL Token mint address
	Mint solanago.PublicKey `json:"mint"`

	// Token decimals
	Decimals uint8 `json:"decimals"`

	// Access manager program
	AccessManager solanago.PublicKey `json:"accessManager"`

	// GMP program for cross-chain calls
	GmpProgram solanago.PublicKey `json:"gmpProgram"`

	// Initialization timestamp
	Timestamp int64 `json:"timestamp"`
}

func (obj IftEventsSplTokenCreated) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `Decimals`:
	err = encoder.Encode(obj.Decimals)
	if err != nil {
		return errors.NewField("Decimals", err)
	}
	// Serialize `AccessManager`:
	err = encoder.Encode(obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Serialize `GmpProgram`:
	err = encoder.Encode(obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj IftEventsSplTokenCreated) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftEventsSplTokenCreated: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftEventsSplTokenCreated) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `Decimals`:
	err = decoder.Decode(&obj.Decimals)
	if err != nil {
		return errors.NewField("Decimals", err)
	}
	// Deserialize `AccessManager`:
	err = decoder.Decode(&obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Deserialize `GmpProgram`:
	err = decoder.Decode(&obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	return nil
}

func (obj *IftEventsSplTokenCreated) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftEventsSplTokenCreated: %w", err)
	}
	return nil
}

func UnmarshalIftEventsSplTokenCreated(buf []byte) (*IftEventsSplTokenCreated, error) {
	obj := new(IftEventsSplTokenCreated)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Account schema version for upgrades
type IftStateAccountVersion binary.BorshEnum

const (
	IftStateAccountVersion_V1 IftStateAccountVersion = iota
)

func (value IftStateAccountVersion) String() string {
	switch value {
	case IftStateAccountVersion_V1:
		return "V1"
	default:
		return ""
	}
}

// Chain-specific options for counterparty chain configuration
// The "isIftStateChainOptions" interface for the "IftStateChainOptions" complex enum.
type IftStateChainOptions interface {
	isIftStateChainOptions()
}

type iftStateChainOptionsEnumContainer struct {
	Enum   binary.BorshEnum `bin:"enum"`
	Evm    IftStateChainOptions_Evm
	Cosmos IftStateChainOptions_Cosmos
}

func DecodeIftStateChainOptions(decoder *binary.Decoder) (IftStateChainOptions, error) {
	{
		tmp := new(iftStateChainOptionsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing IftStateChainOptions: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*IftStateChainOptions_Evm)(&tmp.Enum), nil
		case 1:
			return &tmp.Cosmos, nil
		default:
			return nil, fmt.Errorf("IftStateChainOptions: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeIftStateChainOptions(encoder *binary.Encoder, value IftStateChainOptions) error {
	{
		tmp := iftStateChainOptionsEnumContainer{}
		switch realvalue := value.(type) {
		case *IftStateChainOptions_Evm:
			tmp.Enum = 0
			tmp.Evm = *realvalue
		case *IftStateChainOptions_Cosmos:
			tmp.Enum = 1
			tmp.Cosmos = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type IftStateChainOptions_Evm uint8

func (obj IftStateChainOptions_Evm) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *IftStateChainOptions_Evm) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *IftStateChainOptions_Evm) isIftStateChainOptions() {}

// Variant "Cosmos" of enum "IftStateChainOptions"
type IftStateChainOptions_Cosmos struct {
	Denom      string `json:"denom"`
	TypeUrl    string `json:"typeUrl"`
	IcaAddress string `json:"icaAddress"`
}

func (obj IftStateChainOptions_Cosmos) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Denom`:
	err = encoder.Encode(obj.Denom)
	if err != nil {
		return errors.NewField("Denom", err)
	}
	// Serialize `TypeUrl`:
	err = encoder.Encode(obj.TypeUrl)
	if err != nil {
		return errors.NewField("TypeUrl", err)
	}
	// Serialize `IcaAddress`:
	err = encoder.Encode(obj.IcaAddress)
	if err != nil {
		return errors.NewField("IcaAddress", err)
	}
	return nil
}

func (obj IftStateChainOptions_Cosmos) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateChainOptions_Cosmos: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateChainOptions_Cosmos) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Denom`:
	err = decoder.Decode(&obj.Denom)
	if err != nil {
		return errors.NewField("Denom", err)
	}
	// Deserialize `TypeUrl`:
	err = decoder.Decode(&obj.TypeUrl)
	if err != nil {
		return errors.NewField("TypeUrl", err)
	}
	// Deserialize `IcaAddress`:
	err = decoder.Decode(&obj.IcaAddress)
	if err != nil {
		return errors.NewField("IcaAddress", err)
	}
	return nil
}

func (obj *IftStateChainOptions_Cosmos) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateChainOptions_Cosmos: %w", err)
	}
	return nil
}

func UnmarshalIftStateChainOptions_Cosmos(buf []byte) (*IftStateChainOptions_Cosmos, error) {
	obj := new(IftStateChainOptions_Cosmos)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *IftStateChainOptions_Cosmos) isIftStateChainOptions() {}

// Main IFT application state
// PDA Seeds: [`IFT_APP_STATE_SEED`, `mint.as_ref()`]
type IftStateIftAppState struct {
	Version IftStateAccountVersion `json:"version"`
	Bump    uint8                  `json:"bump"`

	// SPL Token mint address (this IFT controls this mint)
	Mint solanago.PublicKey `json:"mint"`

	// Mint authority PDA bump for signing mint/refund operations.
	// Stored to use `create_program_address` (~1.5k CUs) instead of
	// `find_program_address` (~10k CUs) on each mint/refund.
	MintAuthorityBump uint8 `json:"mintAuthorityBump"`

	// Access manager program ID for role-based access control
	AccessManager solanago.PublicKey `json:"accessManager"`

	// GMP program address for sending cross-chain calls
	GmpProgram solanago.PublicKey `json:"gmpProgram"`
	Reserved   [128]uint8         `json:"reserved"`
}

func (obj IftStateIftAppState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `MintAuthorityBump`:
	err = encoder.Encode(obj.MintAuthorityBump)
	if err != nil {
		return errors.NewField("MintAuthorityBump", err)
	}
	// Serialize `AccessManager`:
	err = encoder.Encode(obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Serialize `GmpProgram`:
	err = encoder.Encode(obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj IftStateIftAppState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateIftAppState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateIftAppState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `MintAuthorityBump`:
	err = decoder.Decode(&obj.MintAuthorityBump)
	if err != nil {
		return errors.NewField("MintAuthorityBump", err)
	}
	// Deserialize `AccessManager`:
	err = decoder.Decode(&obj.AccessManager)
	if err != nil {
		return errors.NewField("AccessManager", err)
	}
	// Deserialize `GmpProgram`:
	err = decoder.Decode(&obj.GmpProgram)
	if err != nil {
		return errors.NewField("GmpProgram", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *IftStateIftAppState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateIftAppState: %w", err)
	}
	return nil
}

func UnmarshalIftStateIftAppState(buf []byte) (*IftStateIftAppState, error) {
	obj := new(IftStateIftAppState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// IFT Bridge configuration for a counterparty chain
type IftStateIftBridge struct {
	Version IftStateAccountVersion `json:"version"`
	Bump    uint8                  `json:"bump"`

	// Mint this bridge is associated with
	Mint solanago.PublicKey `json:"mint"`

	// IBC client identifier for this bridge
	ClientId string `json:"clientId"`

	// IFT contract address on counterparty chain (EVM address or Cosmos bech32)
	CounterpartyIftAddress string `json:"counterpartyIftAddress"`

	// Chain-specific options for constructing mint calls
	ChainOptions IftStateChainOptions `json:"chainOptions"`

	// Whether bridge is active
	Active   bool      `json:"active"`
	Reserved [64]uint8 `json:"reserved"`
}

func (obj IftStateIftBridge) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `CounterpartyIftAddress`:
	err = encoder.Encode(obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Serialize `ChainOptions`:
	{
		err := EncodeIftStateChainOptions(encoder, obj.ChainOptions)
		if err != nil {
			return errors.NewField("ChainOptions", err)
		}
	}
	// Serialize `Active`:
	err = encoder.Encode(obj.Active)
	if err != nil {
		return errors.NewField("Active", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj IftStateIftBridge) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateIftBridge: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateIftBridge) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `CounterpartyIftAddress`:
	err = decoder.Decode(&obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Deserialize `ChainOptions`:
	{
		var err error
		obj.ChainOptions, err = DecodeIftStateChainOptions(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `Active`:
	err = decoder.Decode(&obj.Active)
	if err != nil {
		return errors.NewField("Active", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *IftStateIftBridge) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateIftBridge: %w", err)
	}
	return nil
}

func UnmarshalIftStateIftBridge(buf []byte) (*IftStateIftBridge, error) {
	obj := new(IftStateIftBridge)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for minting IFT tokens (called by GMP)
type IftStateIftMintMsg struct {
	// Receiver pubkey
	Receiver solanago.PublicKey `json:"receiver"`

	// Amount to mint
	Amount uint64 `json:"amount"`
}

func (obj IftStateIftMintMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj IftStateIftMintMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateIftMintMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateIftMintMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *IftStateIftMintMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateIftMintMsg: %w", err)
	}
	return nil
}

func UnmarshalIftStateIftMintMsg(buf []byte) (*IftStateIftMintMsg, error) {
	obj := new(IftStateIftMintMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for initiating an IFT transfer
type IftStateIftTransferMsg struct {
	// IBC client identifier for destination
	ClientId string `json:"clientId"`

	// Receiver address on destination chain
	Receiver string `json:"receiver"`

	// Amount to transfer
	Amount uint64 `json:"amount"`

	// Timeout timestamp (0 for default 15 minutes)
	TimeoutTimestamp int64 `json:"timeoutTimestamp"`
}

func (obj IftStateIftTransferMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `TimeoutTimestamp`:
	err = encoder.Encode(obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	return nil
}

func (obj IftStateIftTransferMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateIftTransferMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateIftTransferMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `TimeoutTimestamp`:
	err = decoder.Decode(&obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	return nil
}

func (obj *IftStateIftTransferMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateIftTransferMsg: %w", err)
	}
	return nil
}

func UnmarshalIftStateIftTransferMsg(buf []byte) (*IftStateIftTransferMsg, error) {
	obj := new(IftStateIftTransferMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Pending transfer tracking for ack/timeout handling
type IftStatePendingTransfer struct {
	Version IftStateAccountVersion `json:"version"`
	Bump    uint8                  `json:"bump"`

	// Mint this transfer is for
	Mint solanago.PublicKey `json:"mint"`

	// Client ID the transfer was sent to
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Original sender (for refunds)
	Sender solanago.PublicKey `json:"sender"`

	// Amount transferred (for refunds)
	Amount uint64 `json:"amount"`

	// Transfer initiation timestamp
	Timestamp int64     `json:"timestamp"`
	Reserved  [32]uint8 `json:"reserved"`
}

func (obj IftStatePendingTransfer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `Mint`:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj IftStatePendingTransfer) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStatePendingTransfer: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStatePendingTransfer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return errors.NewField("Mint", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *IftStatePendingTransfer) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStatePendingTransfer: %w", err)
	}
	return nil
}

func UnmarshalIftStatePendingTransfer(buf []byte) (*IftStatePendingTransfer, error) {
	obj := new(IftStatePendingTransfer)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for registering an IFT bridge
type IftStateRegisterIftBridgeMsg struct {
	// IBC client identifier
	ClientId string `json:"clientId"`

	// Counterparty IFT contract address
	CounterpartyIftAddress string `json:"counterpartyIftAddress"`

	// Chain-specific options
	ChainOptions IftStateChainOptions `json:"chainOptions"`
}

func (obj IftStateRegisterIftBridgeMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `CounterpartyIftAddress`:
	err = encoder.Encode(obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Serialize `ChainOptions`:
	{
		err := EncodeIftStateChainOptions(encoder, obj.ChainOptions)
		if err != nil {
			return errors.NewField("ChainOptions", err)
		}
	}
	return nil
}

func (obj IftStateRegisterIftBridgeMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IftStateRegisterIftBridgeMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IftStateRegisterIftBridgeMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `CounterpartyIftAddress`:
	err = decoder.Decode(&obj.CounterpartyIftAddress)
	if err != nil {
		return errors.NewField("CounterpartyIftAddress", err)
	}
	// Deserialize `ChainOptions`:
	{
		var err error
		obj.ChainOptions, err = DecodeIftStateChainOptions(decoder)
		if err != nil {
			return err
		}
	}
	return nil
}

func (obj *IftStateRegisterIftBridgeMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IftStateRegisterIftBridgeMsg: %w", err)
	}
	return nil
}

func UnmarshalIftStateRegisterIftBridgeMsg(buf []byte) (*IftStateRegisterIftBridgeMsg, error) {
	obj := new(IftStateRegisterIftBridgeMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Status of a GMP call result.
// The "isSolanaIbcTypesIcs27CallResultStatus" interface for the "SolanaIbcTypesIcs27CallResultStatus" complex enum.
type SolanaIbcTypesIcs27CallResultStatus interface {
	isSolanaIbcTypesIcs27CallResultStatus()
}

type solanaIbcTypesIcs27CallResultStatusEnumContainer struct {
	Enum            binary.BorshEnum `bin:"enum"`
	Acknowledgement SolanaIbcTypesIcs27CallResultStatus_Acknowledgement
	Timeout         SolanaIbcTypesIcs27CallResultStatus_Timeout
}

func DecodeSolanaIbcTypesIcs27CallResultStatus(decoder *binary.Decoder) (SolanaIbcTypesIcs27CallResultStatus, error) {
	{
		tmp := new(solanaIbcTypesIcs27CallResultStatusEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing SolanaIbcTypesIcs27CallResultStatus: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.Acknowledgement, nil
		case 1:
			return (*SolanaIbcTypesIcs27CallResultStatus_Timeout)(&tmp.Enum), nil
		default:
			return nil, fmt.Errorf("SolanaIbcTypesIcs27CallResultStatus: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeSolanaIbcTypesIcs27CallResultStatus(encoder *binary.Encoder, value SolanaIbcTypesIcs27CallResultStatus) error {
	{
		tmp := solanaIbcTypesIcs27CallResultStatusEnumContainer{}
		switch realvalue := value.(type) {
		case *SolanaIbcTypesIcs27CallResultStatus_Acknowledgement:
			tmp.Enum = 0
			tmp.Acknowledgement = *realvalue
		case *SolanaIbcTypesIcs27CallResultStatus_Timeout:
			tmp.Enum = 1
			tmp.Timeout = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "Acknowledgement" of enum "SolanaIbcTypesIcs27CallResultStatus"
type SolanaIbcTypesIcs27CallResultStatus_Acknowledgement struct {
	V0 [32]uint8 `json:"v0"`
}

func (obj SolanaIbcTypesIcs27CallResultStatus_Acknowledgement) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	err = encoder.Encode(obj.V0)
	if err != nil {
		return errors.NewField("V0", err)
	}
	return nil
}

func (obj SolanaIbcTypesIcs27CallResultStatus_Acknowledgement) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SolanaIbcTypesIcs27CallResultStatus_Acknowledgement: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SolanaIbcTypesIcs27CallResultStatus_Acknowledgement) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	err = decoder.Decode(&obj.V0)
	if err != nil {
		return errors.NewField("V0", err)
	}
	return nil
}

func (obj *SolanaIbcTypesIcs27CallResultStatus_Acknowledgement) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SolanaIbcTypesIcs27CallResultStatus_Acknowledgement: %w", err)
	}
	return nil
}

func UnmarshalSolanaIbcTypesIcs27CallResultStatus_Acknowledgement(buf []byte) (*SolanaIbcTypesIcs27CallResultStatus_Acknowledgement, error) {
	obj := new(SolanaIbcTypesIcs27CallResultStatus_Acknowledgement)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *SolanaIbcTypesIcs27CallResultStatus_Acknowledgement) isSolanaIbcTypesIcs27CallResultStatus() {
}

type SolanaIbcTypesIcs27CallResultStatus_Timeout uint8

func (obj SolanaIbcTypesIcs27CallResultStatus_Timeout) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SolanaIbcTypesIcs27CallResultStatus_Timeout) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *SolanaIbcTypesIcs27CallResultStatus_Timeout) isSolanaIbcTypesIcs27CallResultStatus() {}
