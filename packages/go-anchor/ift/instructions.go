// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ift

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize global IFT state (once-only)
func NewInitializeInstruction(
	// Params:
	adminParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `adminParam`:
		err = enc__.Encode(adminParam)
		if err != nil {
			return nil, errors.NewField("adminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// Global IFT app state PDA (to be created, singleton)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_and_initialize_spl_token" instruction.
// Create and initialize a new SPL token mint for IFT. // Pass `CreateTokenParams::SplToken` for legacy or `CreateTokenParams::Token2022` // for a mint with `MetadataPointer` and on-chain metadata.
func NewCreateAndInitializeSplTokenInstruction(
	// Params:
	paramsParam IftStateCreateTokenParams,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateAndInitializeSplToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		{
			err := EncodeIftStateCreateTokenParams(enc__, paramsParam)
			if err != nil {
				return nil, errors.NewField("paramsParam", err)
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (must exist)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "mint": Writable, Signer, Required
		// SPL Token mint keypair. Must sign so `create_account` can allocate it.
		// Initialized manually to support Token 2022 extensions.
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, true))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "admin": Read-only, Signer, Required
		// Admin authority
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_existing_token" instruction.
// Initialize IFT for an existing SPL token by transferring mint authority
func NewInitializeExistingTokenInstruction(
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	currentAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeExistingToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (must exist)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "current_authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(currentAuthorityAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "register_ift_bridge" instruction.
// Register an IFT bridge to a counterparty chain
func NewRegisterIftBridgeInstruction(
	// Params:
	msgParam IftStateRegisterIftBridgeMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RegisterIftBridge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for admin check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Read-only, Non-signer, Required
		// Per-mint IFT app state (for mint reference)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, false, false))
		// Account 2 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 3 "admin": Read-only, Signer, Required
		// Admin authority
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_ift_bridge" instruction.
// Remove an IFT bridge
func NewRemoveIftBridgeInstruction(
	// Params:
	clientIdParam string,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveIftBridge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for admin check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Read-only, Non-signer, Required
		// Per-mint IFT app state (for mint reference)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, false, false))
		// Account 2 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge to remove (close and refund rent)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 3 "admin": Read-only, Signer, Required
		// Admin authority
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ift_transfer" instruction.
// Initiate an IFT transfer to another chain // Burns tokens and sends GMP call to mint on destination
func NewIftTransferInstruction(
	// Params:
	msgParam IftStateIftTransferMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	gmpProgramAccount solanago.PublicKey,
	gmpAppStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	gmpIbcAppAccount solanago.PublicKey,
	ibcClientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	lightClientStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, false, false))
		// Account 2 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge for the destination
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "sender_token_account": Writable, Non-signer, Required
		// Sender's token account
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 5 "sender": Read-only, Signer, Required
		// Sender who owns the tokens
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 6 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 7 "token_program": Read-only, Non-signer, Required
		// Required for burning tokens from sender's account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "gmp_program": Read-only, Non-signer, Required, Address: 3W3h4WSE8J9vFzVN8TGFGc9Uchbry3M4MBz4icdSWcFi
		accounts__.Append(solanago.NewAccountMeta(gmpProgramAccount, false, false))
		// Account 10 "gmp_app_state": Writable, Non-signer, Required
		// GMP app state PDA
		accounts__.Append(solanago.NewAccountMeta(gmpAppStateAccount, true, false))
		// Account 11 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 12 "router_state": Read-only, Non-signer, Required
		// Router state account
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 13 "client_sequence": Writable, Non-signer, Required
		// Client sequence account for packet sequencing
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 14 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment account to be created
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 15 "gmp_ibc_app": Read-only, Non-signer, Required
		// GMP's IBC app registration account — required by the router for
		// authorization and deterministic sequence namespacing (the router hashes
		// `app_program_id` to derive a collision-resistant sequence suffix).
		accounts__.Append(solanago.NewAccountMeta(gmpIbcAppAccount, false, false))
		// Account 16 "ibc_client": Read-only, Non-signer, Required
		// IBC client account
		accounts__.Append(solanago.NewAccountMeta(ibcClientAccount, false, false))
		// Account 17 "light_client_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 18 "light_client_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lightClientStateAccount, false, false))
		// Account 19 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI caller detection by GMP
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 20 "consensus_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
		// Account 21 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer account - manually created with runtime-calculated sequence
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ift_mint" instruction.
// Mint IFT tokens (called by GMP when receiving cross-chain transfer).
func NewIftMintInstruction(
	// Params:
	msgParam IftStateIftMintMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
	receiverOwnerAccount solanago.PublicKey,
	gmpAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for paused check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state (mut, for rate limits)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge - provides counterparty info for GMP account validation.
		// Seeds use self-referencing `ift_bridge.client_id` (Anchor deserializes before checking seeds).
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 5 "receiver_token_account": Writable, Non-signer, Required
		// Receiver's token account (will be created if needed)
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
		// Account 6 "receiver_owner": Read-only, Non-signer, Required
		// Constraint prevents relayer from substituting a different receiver than specified in cross-chain message.
		accounts__.Append(solanago.NewAccountMeta(receiverOwnerAccount, false, false))
		// Account 7 "gmp_account": Read-only, Signer, Required
		// GMP account PDA - validated to match counterparty bridge
		accounts__.Append(solanago.NewAccountMeta(gmpAccountAccount, false, true))
		// Account 8 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 11 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_transfer" instruction.
// Finalize a pending transfer after GMP result is recorded and proved ack/timeout.
func NewFinalizeTransferInstruction(
	// Params:
	clientIdParam string,
	sequenceParam uint64,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
	gmpResultAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
		// Serialize `sequenceParam`:
		err = enc__.Encode(sequenceParam)
		if err != nil {
			return nil, errors.NewField("sequenceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state (mut for rate limit updates)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge for this client
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 3 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer to process
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
		// Account 4 "gmp_result": Read-only, Non-signer, Required
		// GMP result account - proves the ack/timeout happened
		// This is a cross-program account owned by the GMP program
		accounts__.Append(solanago.NewAccountMeta(gmpResultAccount, false, false))
		// Account 5 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 6 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 7 "sender_token_account": Writable, Non-signer, Required
		// Original sender's token account for refunds.
		//
		// The caller provides this account but cannot redirect funds — the owner
		// constraint ensures refunds always go to the original sender. Owning the
		// `sender_token_account` private key is NOT required; the refund is
		// authorized by the program via the mint authority PDA.
		//
		// If the sender's token account no longer exists (e.g. was closed), the
		// transaction will fail. A new ATA must be created for the sender before
		// calling this instruction.
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 8 "payer": Writable, Signer, Required
		// Only required signer. Receives rent from the closed `PendingTransfer`
		// account as an incentive. Does not need to be the original sender.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_admin" instruction.
// Set the admin authority (admin only)
func NewSetAdminInstruction(
	// Params:
	newAdminParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAdminParam`:
		err = enc__.Encode(newAdminParam)
		if err != nil {
			return nil, errors.NewField("newAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "revoke_mint_authority" instruction.
// Revoke mint authority from IFT and transfer it to a new authority.
func NewRevokeMintAuthorityInstruction(
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	newMintAuthorityAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RevokeMintAuthority[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for admin check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Read-only, Non-signer, Required
		// Per-mint IFT app state (for `mint_authority_bump`)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint - authority will be transferred
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Current mint authority PDA (IFT's)
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "new_mint_authority": Read-only, Non-signer, Required
		// New mint authority to receive ownership
		accounts__.Append(solanago.NewAccountMeta(newMintAuthorityAccount, false, false))
		// Account 5 "admin": Read-only, Signer, Required
		// Admin signer
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 6 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_mint_rate_limit" instruction.
// Set the daily mint rate limit (admin only)
func NewSetMintRateLimitInstruction(
	// Params:
	msgParam IftStateSetMintRateLimitMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMintRateLimit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for admin check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state (mut, for `daily_mint_limit`)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_paused" instruction.
// Pause or unpause an IFT token (admin only)
func NewSetPausedInstruction(
	// Params:
	msgParam IftStateSetPausedMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPaused[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 2 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "admin_mint" instruction.
// Mint tokens to any account (admin only)
func NewAdminMintInstruction(
	// Params:
	msgParam IftStateAdminMintMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	appMintStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
	receiverOwnerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AdminMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// Global IFT app state (read-only, for admin + pause check)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "app_mint_state": Writable, Non-signer, Required
		// Per-mint IFT app state (mut for rate limits)
		accounts__.Append(solanago.NewAccountMeta(appMintStateAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "receiver_token_account": Writable, Non-signer, Required
		// Receiver's token account (will be created if needed)
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
		// Account 5 "receiver_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverOwnerAccount, false, false))
		// Account 6 "admin": Read-only, Signer, Required
		// Admin signer
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 7 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 8 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
