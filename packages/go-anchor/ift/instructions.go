// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ift

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "create_spl_token" instruction.
// Create a new SPL token mint for IFT
func NewCreateSplTokenInstruction(
	// Params:
	decimalsParam uint8,
	adminParam solanago.PublicKey,
	gmpProgramParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateSplToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `decimalsParam`:
		err = enc__.Encode(decimalsParam)
		if err != nil {
			return nil, errors.NewField("decimalsParam", err)
		}
		// Serialize `adminParam`:
		err = enc__.Encode(adminParam)
		if err != nil {
			return nil, errors.NewField("adminParam", err)
		}
		// Serialize `gmpProgramParam`:
		err = enc__.Encode(gmpProgramParam)
		if err != nil {
			return nil, errors.NewField("gmpProgramParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// IFT app state PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "mint": Writable, Signer, Required
		// SPL Token mint (created by IFT with PDA as authority)
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, true))
		// Account 2 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_existing_token" instruction.
// Initialize IFT for an existing SPL token by transferring mint authority
func NewInitializeExistingTokenInstruction(
	// Params:
	adminParam solanago.PublicKey,
	gmpProgramParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	currentAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeExistingToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `adminParam`:
		err = enc__.Encode(adminParam)
		if err != nil {
			return nil, errors.NewField("adminParam", err)
		}
		// Serialize `gmpProgramParam`:
		err = enc__.Encode(gmpProgramParam)
		if err != nil {
			return nil, errors.NewField("gmpProgramParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 2 "mint_authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 3 "current_authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(currentAuthorityAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "register_ift_bridge" instruction.
// Register an IFT bridge to a counterparty chain
func NewRegisterIftBridgeInstruction(
	// Params:
	msgParam IftStateRegisterIftBridgeMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RegisterIftBridge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Admin authority
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_ift_bridge" instruction.
// Remove an IFT bridge
func NewRemoveIftBridgeInstruction(
	// Params:
	clientIdParam string,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveIftBridge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge to remove (close and refund rent)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Admin authority
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ift_transfer" instruction.
// Initiate an IFT transfer to another chain // Burns tokens and sends GMP call to mint on destination
func NewIftTransferInstruction(
	// Params:
	msgParam IftStateIftTransferMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	gmpProgramAccount solanago.PublicKey,
	gmpAppStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	gmpIbcAppAccount solanago.PublicKey,
	ibcClientAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge for the destination
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "sender_token_account": Writable, Non-signer, Required
		// Sender's token account
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 4 "sender": Read-only, Signer, Required
		// Sender who owns the tokens
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Required for burning tokens from sender's account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "gmp_program": Read-only, Non-signer, Required
		// GMP program
		accounts__.Append(solanago.NewAccountMeta(gmpProgramAccount, false, false))
		// Account 9 "gmp_app_state": Writable, Non-signer, Required
		// GMP app state PDA
		accounts__.Append(solanago.NewAccountMeta(gmpAppStateAccount, true, false))
		// Account 10 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 11 "router_state": Read-only, Non-signer, Required
		// Router state account
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 12 "client_sequence": Writable, Non-signer, Required
		// Client sequence account for packet sequencing
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 13 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment account to be created
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 14 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 15 "gmp_ibc_app": Read-only, Non-signer, Required
		// GMP's IBC app registration account
		accounts__.Append(solanago.NewAccountMeta(gmpIbcAppAccount, false, false))
		// Account 16 "ibc_client": Read-only, Non-signer, Required
		// IBC client account
		accounts__.Append(solanago.NewAccountMeta(ibcClientAccount, false, false))
		// Account 17 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer account - manually created with runtime-calculated sequence
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ift_mint" instruction.
// Mint IFT tokens (called by GMP when receiving cross-chain transfer).
func NewIftMintInstruction(
	// Params:
	msgParam IftStateIftMintMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
	receiverOwnerAccount solanago.PublicKey,
	gmpProgramAccount solanago.PublicKey,
	gmpAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge - provides counterparty info for GMP account validation.
		// Relayer passes the correct bridge; validation ensures bridge matches GMP account.
		// Security: Anchor verifies ownership, `validate_gmp_account` verifies (`client_id`, counterparty) match.
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "receiver_token_account": Writable, Non-signer, Required
		// Receiver's token account (will be created if needed)
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
		// Account 5 "receiver_owner": Read-only, Non-signer, Required
		// Constraint prevents relayer from substituting a different receiver than specified in cross-chain message.
		accounts__.Append(solanago.NewAccountMeta(receiverOwnerAccount, false, false))
		// Account 6 "gmp_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(gmpProgramAccount, false, false))
		// Account 7 "gmp_account": Read-only, Signer, Required
		// GMP account PDA - validated to match counterparty bridge
		accounts__.Append(solanago.NewAccountMeta(gmpAccountAccount, false, true))
		// Account 8 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 11 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_transfer" instruction.
// Finalize a pending transfer after GMP result is recorded and proved ack/timeout.
func NewFinalizeTransferInstruction(
	// Params:
	clientIdParam string,
	sequenceParam uint64,

	// Accounts:
	appStateAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
	gmpResultAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
		// Serialize `sequenceParam`:
		err = enc__.Encode(sequenceParam)
		if err != nil {
			return nil, errors.NewField("sequenceParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// IFT app state
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer to process
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
		// Account 2 "gmp_result": Read-only, Non-signer, Required
		// GMP result account - proves the ack/timeout happened
		// This is a cross-program account owned by the GMP program
		accounts__.Append(solanago.NewAccountMeta(gmpResultAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 5 "sender_token_account": Writable, Non-signer, Required
		// Original sender's token account (for refunds)
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 6 "payer": Writable, Signer, Required
		// Payer receives rent from closed `PendingTransfer` account
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 7 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_admin" instruction.
// Set the admin authority (admin only)
func NewSetAdminInstruction(
	// Params:
	newAdminParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAdminParam`:
		err = enc__.Encode(newAdminParam)
		if err != nil {
			return nil, errors.NewField("newAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "revoke_mint_authority" instruction.
// Revoke mint authority from IFT and transfer it to a new authority.
func NewRevokeMintAuthorityInstruction(
	appStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	newMintAuthorityAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RevokeMintAuthority[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// IFT app state (will be closed)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "mint": Writable, Non-signer, Required
		// SPL Token mint - authority will be transferred
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 2 "mint_authority": Read-only, Non-signer, Required
		// Current mint authority PDA (IFT's)
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 3 "new_mint_authority": Read-only, Non-signer, Required
		// New mint authority to receive ownership
		accounts__.Append(solanago.NewAccountMeta(newMintAuthorityAccount, false, false))
		// Account 4 "admin": Read-only, Signer, Required
		// Admin signer
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		// Payer receives rent from closed `app_state`
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_mint_rate_limit" instruction.
// Set the daily mint rate limit (admin only)
func NewSetMintRateLimitInstruction(
	// Params:
	msgParam IftStateSetMintRateLimitMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMintRateLimit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_paused" instruction.
// Pause or unpause an IFT token (admin only)
func NewSetPausedInstruction(
	// Params:
	msgParam IftStateSetPausedMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPaused[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "admin_mint" instruction.
// Mint tokens to any account (admin only)
func NewAdminMintInstruction(
	// Params:
	msgParam IftStateAdminMintMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
	receiverOwnerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AdminMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 2 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 3 "receiver_token_account": Writable, Non-signer, Required
		// Receiver's token account (will be created if needed)
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
		// Account 4 "receiver_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverOwnerAccount, false, false))
		// Account 5 "admin": Read-only, Signer, Required
		// Admin signer
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 6 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 7 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 8 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
