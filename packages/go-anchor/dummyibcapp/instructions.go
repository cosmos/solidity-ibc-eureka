// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package dummy_ibc_app

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the dummy IBC app
func NewInitializeInstruction(
	// Params:
	authorityParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `authorityParam`:
		err = enc__.Encode(authorityParam)
		if err != nil {
			return nil, errors.NewField("authorityParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_acknowledgement_packet" instruction.
// Handle packet acknowledgement
func NewOnAcknowledgementPacketInstruction(
	// Params:
	msgParam OnAcknowledgementPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnAcknowledgementPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "router_program": Read-only, Non-signer, Required
		// The IBC router program that's calling us
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Payer for account creation if needed
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_recv_packet" instruction.
// Handle incoming packet // Returns acknowledgement data via `set_return_data`
func NewOnRecvPacketInstruction(
	// Params:
	msgParam OnRecvPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnRecvPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "router_program": Read-only, Non-signer, Required
		// The IBC router program that's calling us
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Payer for account creation if needed
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_timeout_packet" instruction.
// Handle packet timeout
func NewOnTimeoutPacketInstruction(
	// Params:
	msgParam OnTimeoutPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	escrowAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnTimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "router_program": Read-only, Non-signer, Required
		// The IBC router program that's calling us
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "escrow_account": Writable, Non-signer, Optional
		// Escrow account that holds SOL (funds remain in escrow on timeout)
		accounts__.Append(solanago.NewAccountMeta(escrowAccountAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Payer for account creation if needed
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_packet" instruction.
// Send an arbitrary packet via IBC
func NewSendPacketInstruction(
	// Params:
	msgParam SendPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	clockAccount solanago.PublicKey,
	routerCallerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "user": Writable, Signer, Required
		// User sending the packet
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, true))
		// Account 2 "router_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 3 "ibc_app": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 4 "client_sequence": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 5 "packet_commitment": Writable, Non-signer, Required
		// Will be created by the router
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 6 "client": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 7 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program for CPI
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		// Clock sysvar for timeout validation
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
		// Account 10 "router_caller": Read-only, Non-signer, Required
		// PDA that acts as the router caller for CPI calls to the IBC router.
		accounts__.Append(solanago.NewAccountMeta(routerCallerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_transfer" instruction.
// Send a transfer packet via IBC
func NewSendTransferInstruction(
	// Params:
	msgParam SendTransferMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	userAccount solanago.PublicKey,
	escrowAccountAccount solanago.PublicKey,
	escrowStateAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	clockAccount solanago.PublicKey,
	routerCallerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "user": Writable, Signer, Required
		// User sending the transfer
		accounts__.Append(solanago.NewAccountMeta(userAccount, true, true))
		// Account 2 "escrow_account": Writable, Non-signer, Required
		// Escrow account to hold SOL during transfer
		accounts__.Append(solanago.NewAccountMeta(escrowAccountAccount, true, false))
		// Account 3 "escrow_state": Writable, Non-signer, Required
		// Optional escrow state to track transfers (created if needed)
		accounts__.Append(solanago.NewAccountMeta(escrowStateAccount, true, false))
		// Account 4 "router_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 5 "ibc_app": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 6 "client_sequence": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 7 "packet_commitment": Writable, Non-signer, Required
		// Will be created by the router
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 8 "client": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 9 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program for CPI
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 11 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		// Clock sysvar for timeout validation
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
		// Account 12 "router_caller": Read-only, Non-signer, Required
		// PDA that acts as the router caller for CPI calls to the IBC router.
		accounts__.Append(solanago.NewAccountMeta(routerCallerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
