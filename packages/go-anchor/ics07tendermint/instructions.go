// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics07_tendermint

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	clientStateParam Ics07TendermintTypesClientState,
	consensusStateParam Ics07TendermintTypesConsensusState,
	accessManagerParam solanago.PublicKey,

	// Accounts:
	clientStateAccountAccount solanago.PublicKey,
	consensusStateStoreAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientStateParam`:
		err = enc__.Encode(clientStateParam)
		if err != nil {
			return nil, errors.NewField("clientStateParam", err)
		}
		// Serialize `consensusStateParam`:
		err = enc__.Encode(consensusStateParam)
		if err != nil {
			return nil, errors.NewField("consensusStateParam", err)
		}
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state_account": Writable, Non-signer, Required
		// PDA holding the Tendermint light client configuration and tracking state.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccountAccount, true, false))
		// Account 1 "consensus_state_store": Writable, Non-signer, Required
		// PDA storing the verified consensus state at the initial height.
		accounts__.Append(solanago.NewAccountMeta(consensusStateStoreAccount, true, false))
		// Account 2 "app_state": Writable, Non-signer, Required
		// PDA holding program-level settings such as the `access_manager` address and `chain_id`.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 3 "payer": Writable, Signer, Required
		// Signer that pays for PDA account creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		// Required by Anchor for PDA creation via the System Program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_access_manager" instruction.
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// PDA holding program-level settings; the `access_manager` field is overwritten on success.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Current access-manager PDA used to verify the caller holds the admin role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Admin signer authorized to change the access manager.
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used by the access manager to inspect the transaction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "verify_membership" instruction.
func NewVerifyMembershipInstruction(
	// Params:
	msgParam Ics25HandlerMembershipMsg,

	// Accounts:
	clientStateAccount solanago.PublicKey,
	consensusStateAtHeightAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_VerifyMembership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state": Read-only, Non-signer, Required
		// PDA holding the light client configuration; used to check the frozen status.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 1 "consensus_state_at_height": Read-only, Non-signer, Required
		// PDA storing the verified consensus state at the requested proof height.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAtHeightAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "verify_non_membership" instruction.
// Verifies the absence of a value at a given path in the counterparty chain state. // Returns the timestamp of the consensus state at the proof height in unix seconds.
func NewVerifyNonMembershipInstruction(
	// Params:
	msgParam Ics25HandlerNonMembershipMsg,

	// Accounts:
	clientStateAccount solanago.PublicKey,
	consensusStateAtHeightAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_VerifyNonMembership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state": Read-only, Non-signer, Required
		// PDA holding the light client configuration; used to check the frozen status.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 1 "consensus_state_at_height": Read-only, Non-signer, Required
		// PDA storing the verified consensus state at the requested proof height.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAtHeightAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "upload_header_chunk" instruction.
// Upload a chunk of header data for multi-transaction updates // Fails if a chunk already exists at this position (no overwrites allowed)
func NewUploadHeaderChunkInstruction(
	// Params:
	paramsParam Ics07TendermintTypesUploadChunkParams,

	// Accounts:
	chunkAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	submitterAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UploadHeaderChunk[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "chunk": Writable, Non-signer, Required
		// PDA storing one segment of the serialized header, keyed by submitter, target height and chunk index.
		accounts__.Append(solanago.NewAccountMeta(chunkAccount, true, false))
		// Account 1 "client_state": Read-only, Non-signer, Required
		// PDA holding the light client configuration; used to check the frozen status.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 2 "app_state": Read-only, Non-signer, Required
		// PDA holding program-level settings; provides the `access_manager` address for role checks.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 3 "access_manager": Read-only, Non-signer, Required
		// Access-manager PDA used to verify the submitter holds the relayer role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 4 "submitter": Writable, Signer, Required
		// Relayer that signs the transaction and pays for chunk account creation.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
		// Account 5 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used by the access manager to inspect the transaction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Required by Anchor for PDA creation via the System Program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "assemble_and_update_client" instruction.
// Assemble chunks and update the client // Automatically cleans up all chunks after successful update
func NewAssembleAndUpdateClientInstruction(
	// Params:
	targetHeightParam uint64,
	chunkCountParam uint8,
	trustedHeightParam uint64,

	// Accounts:
	clientStateAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	trustedConsensusStateAccount solanago.PublicKey,
	newConsensusStateStoreAccount solanago.PublicKey,
	submitterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AssembleAndUpdateClient[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `targetHeightParam`:
		err = enc__.Encode(targetHeightParam)
		if err != nil {
			return nil, errors.NewField("targetHeightParam", err)
		}
		// Serialize `chunkCountParam`:
		err = enc__.Encode(chunkCountParam)
		if err != nil {
			return nil, errors.NewField("chunkCountParam", err)
		}
		// Serialize `trustedHeightParam`:
		err = enc__.Encode(trustedHeightParam)
		if err != nil {
			return nil, errors.NewField("trustedHeightParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state": Writable, Non-signer, Required
		// PDA holding the light client configuration; updated with the new latest height on success.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, true, false))
		// Account 1 "app_state": Read-only, Non-signer, Required
		// PDA holding program-level settings; provides the `access_manager` address for role checks.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		// Access-manager PDA used to verify the submitter holds the relayer role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "trusted_consensus_state": Read-only, Non-signer, Required
		// Consensus state the header declares as its trust anchor; validated against PDA seeds.
		accounts__.Append(solanago.NewAccountMeta(trustedConsensusStateAccount, false, false))
		// Account 4 "new_consensus_state_store": Writable, Non-signer, Required
		// Destination PDA for the newly derived consensus state; created if it does not already exist.
		accounts__.Append(solanago.NewAccountMeta(newConsensusStateStoreAccount, true, false))
		// Account 5 "submitter": Writable, Signer, Required
		// Relayer that uploaded the chunks, signs the assembly transaction and receives rent refunds.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Required by Anchor for creating the new consensus-state PDA.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used by the access manager to inspect the transaction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cleanup_incomplete_upload" instruction.
// Clean up incomplete header uploads // This can be called to reclaim rent from failed or abandoned uploads // Closes both `HeaderChunk` and `SignatureVerification` PDAs owned by the submitter
func NewCleanupIncompleteUploadInstruction(
	submitterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CleanupIncompleteUpload[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "submitter": Writable, Signer, Required
		// Original submitter who uploaded the chunks; must sign to prove ownership and receives rent refunds.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "upload_misbehaviour_chunk" instruction.
// Upload a chunk of misbehaviour data for multi-transaction submission
func NewUploadMisbehaviourChunkInstruction(
	// Params:
	paramsParam Ics07TendermintTypesUploadMisbehaviourChunkParams,

	// Accounts:
	chunkAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	submitterAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UploadMisbehaviourChunk[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "chunk": Writable, Non-signer, Required
		// PDA storing one segment of the serialized misbehaviour, keyed by submitter and chunk index.
		accounts__.Append(solanago.NewAccountMeta(chunkAccount, true, false))
		// Account 1 "client_state": Read-only, Non-signer, Required
		// PDA holding the light client configuration; used to check the frozen status.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 2 "app_state": Read-only, Non-signer, Required
		// PDA holding program-level settings; provides the `access_manager` address for role checks.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 3 "access_manager": Read-only, Non-signer, Required
		// Access-manager PDA used to verify the submitter holds the relayer role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 4 "submitter": Writable, Signer, Required
		// Relayer that signs the transaction and pays for chunk account creation.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
		// Account 5 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used by the access manager to inspect the transaction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Required by Anchor for PDA creation via the System Program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "assemble_and_submit_misbehaviour" instruction.
// Assemble chunks and submit misbehaviour // Automatically freezes the client and cleans up all chunks
func NewAssembleAndSubmitMisbehaviourInstruction(
	// Params:
	chunkCountParam uint8,
	trustedHeight1param uint64,
	trustedHeight2param uint64,

	// Accounts:
	clientStateAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	trustedConsensusState1account solanago.PublicKey,
	trustedConsensusState2account solanago.PublicKey,
	submitterAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AssembleAndSubmitMisbehaviour[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chunkCountParam`:
		err = enc__.Encode(chunkCountParam)
		if err != nil {
			return nil, errors.NewField("chunkCountParam", err)
		}
		// Serialize `trustedHeight1param`:
		err = enc__.Encode(trustedHeight1param)
		if err != nil {
			return nil, errors.NewField("trustedHeight1param", err)
		}
		// Serialize `trustedHeight2param`:
		err = enc__.Encode(trustedHeight2param)
		if err != nil {
			return nil, errors.NewField("trustedHeight2param", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state": Writable, Non-signer, Required
		// PDA holding the light client configuration; frozen when misbehaviour is confirmed.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, true, false))
		// Account 1 "app_state": Read-only, Non-signer, Required
		// PDA holding program-level settings; provides the `access_manager` address for role checks.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		// Access-manager PDA used to verify the submitter holds the relayer role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "trusted_consensus_state_1": Read-only, Non-signer, Required
		// First trusted consensus state referenced by the misbehaviour evidence.
		accounts__.Append(solanago.NewAccountMeta(trustedConsensusState1account, false, false))
		// Account 4 "trusted_consensus_state_2": Read-only, Non-signer, Required
		// Second trusted consensus state referenced by the misbehaviour evidence.
		accounts__.Append(solanago.NewAccountMeta(trustedConsensusState2account, false, false))
		// Account 5 "submitter": Writable, Signer, Required
		// Relayer that uploaded the chunks, signs the assembly transaction and receives rent refunds.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
		// Account 6 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used by the access manager to inspect the transaction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cleanup_incomplete_misbehaviour" instruction.
// Clean up incomplete misbehaviour uploads // This can be called to reclaim rent from failed or abandoned misbehaviour submissions
func NewCleanupIncompleteMisbehaviourInstruction(
	submitterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CleanupIncompleteMisbehaviour[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "submitter": Writable, Signer, Required
		// Original submitter who uploaded the chunks; must sign to prove ownership and receives rent refunds.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pre_verify_signature" instruction.
func NewPreVerifySignatureInstruction(
	// Params:
	signatureParam SolanaIbcTypesIcs07SignatureData,

	// Accounts:
	instructionsSysvarAccount solanago.PublicKey,
	signatureVerificationAccount solanago.PublicKey,
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	submitterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PreVerifySignature[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `signatureParam`:
		err = enc__.Encode(signatureParam)
		if err != nil {
			return nil, errors.NewField("signatureParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to load and introspect the preceding Ed25519 verify instruction.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 1 "signature_verification": Writable, Non-signer, Required
		// PDA that stores the Ed25519 verification outcome, keyed by the signature hash.
		accounts__.Append(solanago.NewAccountMeta(signatureVerificationAccount, true, false))
		// Account 2 "app_state": Read-only, Non-signer, Required
		// PDA holding program-level settings; provides the `access_manager` address for role checks.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 3 "access_manager": Read-only, Non-signer, Required
		// Access-manager PDA used to verify the submitter holds the relayer role.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 4 "submitter": Writable, Signer, Required
		// Relayer that signs the transaction and pays for the verification PDA creation.
		accounts__.Append(solanago.NewAccountMeta(submitterAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		// Required by Anchor for PDA creation via the System Program.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "client_status" instruction.
func NewClientStatusInstruction(
	clientStateAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClientStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "client_state": Read-only, Non-signer, Required
		// PDA holding the light client configuration; checked for frozen state and trusting period.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 1 "consensus_state": Read-only, Non-signer, Required
		// Consensus state at the latest height; its timestamp is compared against the
		// current clock to determine whether the client has expired.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
