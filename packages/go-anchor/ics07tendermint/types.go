// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ics07_tendermint

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
)

type ClientState struct {
	ChainId               string    `json:"chainId"`
	TrustLevelNumerator   uint64    `json:"trustLevelNumerator"`
	TrustLevelDenominator uint64    `json:"trustLevelDenominator"`
	TrustingPeriod        uint64    `json:"trustingPeriod"`
	UnbondingPeriod       uint64    `json:"unbondingPeriod"`
	MaxClockDrift         uint64    `json:"maxClockDrift"`
	FrozenHeight          IbcHeight `json:"frozenHeight"`
	LatestHeight          IbcHeight `json:"latestHeight"`
}

func (obj ClientState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ChainId`:
	err = encoder.Encode(obj.ChainId)
	if err != nil {
		return errors.NewField("ChainId", err)
	}
	// Serialize `TrustLevelNumerator`:
	err = encoder.Encode(obj.TrustLevelNumerator)
	if err != nil {
		return errors.NewField("TrustLevelNumerator", err)
	}
	// Serialize `TrustLevelDenominator`:
	err = encoder.Encode(obj.TrustLevelDenominator)
	if err != nil {
		return errors.NewField("TrustLevelDenominator", err)
	}
	// Serialize `TrustingPeriod`:
	err = encoder.Encode(obj.TrustingPeriod)
	if err != nil {
		return errors.NewField("TrustingPeriod", err)
	}
	// Serialize `UnbondingPeriod`:
	err = encoder.Encode(obj.UnbondingPeriod)
	if err != nil {
		return errors.NewField("UnbondingPeriod", err)
	}
	// Serialize `MaxClockDrift`:
	err = encoder.Encode(obj.MaxClockDrift)
	if err != nil {
		return errors.NewField("MaxClockDrift", err)
	}
	// Serialize `FrozenHeight`:
	err = encoder.Encode(obj.FrozenHeight)
	if err != nil {
		return errors.NewField("FrozenHeight", err)
	}
	// Serialize `LatestHeight`:
	err = encoder.Encode(obj.LatestHeight)
	if err != nil {
		return errors.NewField("LatestHeight", err)
	}
	return nil
}

func (obj ClientState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ClientState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ClientState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ChainId`:
	err = decoder.Decode(&obj.ChainId)
	if err != nil {
		return errors.NewField("ChainId", err)
	}
	// Deserialize `TrustLevelNumerator`:
	err = decoder.Decode(&obj.TrustLevelNumerator)
	if err != nil {
		return errors.NewField("TrustLevelNumerator", err)
	}
	// Deserialize `TrustLevelDenominator`:
	err = decoder.Decode(&obj.TrustLevelDenominator)
	if err != nil {
		return errors.NewField("TrustLevelDenominator", err)
	}
	// Deserialize `TrustingPeriod`:
	err = decoder.Decode(&obj.TrustingPeriod)
	if err != nil {
		return errors.NewField("TrustingPeriod", err)
	}
	// Deserialize `UnbondingPeriod`:
	err = decoder.Decode(&obj.UnbondingPeriod)
	if err != nil {
		return errors.NewField("UnbondingPeriod", err)
	}
	// Deserialize `MaxClockDrift`:
	err = decoder.Decode(&obj.MaxClockDrift)
	if err != nil {
		return errors.NewField("MaxClockDrift", err)
	}
	// Deserialize `FrozenHeight`:
	err = decoder.Decode(&obj.FrozenHeight)
	if err != nil {
		return errors.NewField("FrozenHeight", err)
	}
	// Deserialize `LatestHeight`:
	err = decoder.Decode(&obj.LatestHeight)
	if err != nil {
		return errors.NewField("LatestHeight", err)
	}
	return nil
}

func (obj *ClientState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClientState: %w", err)
	}
	return nil
}

func UnmarshalClientState(buf []byte) (*ClientState, error) {
	obj := new(ClientState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConsensusState struct {
	Timestamp          uint64    `json:"timestamp"`
	Root               [32]uint8 `json:"root"`
	NextValidatorsHash [32]uint8 `json:"nextValidatorsHash"`
}

func (obj ConsensusState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Serialize `Root`:
	err = encoder.Encode(obj.Root)
	if err != nil {
		return errors.NewField("Root", err)
	}
	// Serialize `NextValidatorsHash`:
	err = encoder.Encode(obj.NextValidatorsHash)
	if err != nil {
		return errors.NewField("NextValidatorsHash", err)
	}
	return nil
}

func (obj ConsensusState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConsensusState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConsensusState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return errors.NewField("Root", err)
	}
	// Deserialize `NextValidatorsHash`:
	err = decoder.Decode(&obj.NextValidatorsHash)
	if err != nil {
		return errors.NewField("NextValidatorsHash", err)
	}
	return nil
}

func (obj *ConsensusState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConsensusState: %w", err)
	}
	return nil
}

func UnmarshalConsensusState(buf []byte) (*ConsensusState, error) {
	obj := new(ConsensusState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConsensusStateStore struct {
	Height         uint64         `json:"height"`
	ConsensusState ConsensusState `json:"consensusState"`
}

func (obj ConsensusStateStore) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Height`:
	err = encoder.Encode(obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Serialize `ConsensusState`:
	err = encoder.Encode(obj.ConsensusState)
	if err != nil {
		return errors.NewField("ConsensusState", err)
	}
	return nil
}

func (obj ConsensusStateStore) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConsensusStateStore: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConsensusStateStore) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Height`:
	err = decoder.Decode(&obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Deserialize `ConsensusState`:
	err = decoder.Decode(&obj.ConsensusState)
	if err != nil {
		return errors.NewField("ConsensusState", err)
	}
	return nil
}

func (obj *ConsensusStateStore) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConsensusStateStore: %w", err)
	}
	return nil
}

func UnmarshalConsensusStateStore(buf []byte) (*ConsensusStateStore, error) {
	obj := new(ConsensusStateStore)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Storage for a single chunk of header data during multi-transaction upload
type HeaderChunk struct {
	// The chunk data
	ChunkData []byte `json:"chunkData"`
}

func (obj HeaderChunk) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ChunkData`:
	err = encoder.Encode(obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj HeaderChunk) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding HeaderChunk: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *HeaderChunk) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ChunkData`:
	err = decoder.Decode(&obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj *HeaderChunk) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling HeaderChunk: %w", err)
	}
	return nil
}

func UnmarshalHeaderChunk(buf []byte) (*HeaderChunk, error) {
	obj := new(HeaderChunk)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type IbcHeight struct {
	RevisionNumber uint64 `json:"revisionNumber"`
	RevisionHeight uint64 `json:"revisionHeight"`
}

func (obj IbcHeight) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `RevisionNumber`:
	err = encoder.Encode(obj.RevisionNumber)
	if err != nil {
		return errors.NewField("RevisionNumber", err)
	}
	// Serialize `RevisionHeight`:
	err = encoder.Encode(obj.RevisionHeight)
	if err != nil {
		return errors.NewField("RevisionHeight", err)
	}
	return nil
}

func (obj IbcHeight) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IbcHeight: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IbcHeight) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `RevisionNumber`:
	err = decoder.Decode(&obj.RevisionNumber)
	if err != nil {
		return errors.NewField("RevisionNumber", err)
	}
	// Deserialize `RevisionHeight`:
	err = decoder.Decode(&obj.RevisionHeight)
	if err != nil {
		return errors.NewField("RevisionHeight", err)
	}
	return nil
}

func (obj *IbcHeight) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IbcHeight: %w", err)
	}
	return nil
}

func UnmarshalIbcHeight(buf []byte) (*IbcHeight, error) {
	obj := new(IbcHeight)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Standard message structure for membership verification
// All light clients must accept this structure for both membership and non-membership proofs
type MembershipMsg struct {
	// The height at which to verify
	Height uint64 `json:"height"`

	// Delay time period (for time-based delays)
	DelayTimePeriod uint64 `json:"delayTimePeriod"`

	// Delay block period (for block-based delays)
	DelayBlockPeriod uint64 `json:"delayBlockPeriod"`

	// The merkle proof
	Proof []byte `json:"proof"`

	// The merkle path to the value
	Path [][]byte `json:"path"`

	// The value to verify (empty for non-membership)
	Value []byte `json:"value"`
}

func (obj MembershipMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Height`:
	err = encoder.Encode(obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Serialize `DelayTimePeriod`:
	err = encoder.Encode(obj.DelayTimePeriod)
	if err != nil {
		return errors.NewField("DelayTimePeriod", err)
	}
	// Serialize `DelayBlockPeriod`:
	err = encoder.Encode(obj.DelayBlockPeriod)
	if err != nil {
		return errors.NewField("DelayBlockPeriod", err)
	}
	// Serialize `Proof`:
	err = encoder.Encode(obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	// Serialize `Path`:
	err = encoder.Encode(obj.Path)
	if err != nil {
		return errors.NewField("Path", err)
	}
	// Serialize `Value`:
	err = encoder.Encode(obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj MembershipMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MembershipMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MembershipMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Height`:
	err = decoder.Decode(&obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Deserialize `DelayTimePeriod`:
	err = decoder.Decode(&obj.DelayTimePeriod)
	if err != nil {
		return errors.NewField("DelayTimePeriod", err)
	}
	// Deserialize `DelayBlockPeriod`:
	err = decoder.Decode(&obj.DelayBlockPeriod)
	if err != nil {
		return errors.NewField("DelayBlockPeriod", err)
	}
	// Deserialize `Proof`:
	err = decoder.Decode(&obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	// Deserialize `Path`:
	err = decoder.Decode(&obj.Path)
	if err != nil {
		return errors.NewField("Path", err)
	}
	// Deserialize `Value`:
	err = decoder.Decode(&obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj *MembershipMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MembershipMsg: %w", err)
	}
	return nil
}

func UnmarshalMembershipMsg(buf []byte) (*MembershipMsg, error) {
	obj := new(MembershipMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MisbehaviourMsg struct {
	ClientId     string `json:"clientId"`
	Misbehaviour []byte `json:"misbehaviour"`
}

func (obj MisbehaviourMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Misbehaviour`:
	err = encoder.Encode(obj.Misbehaviour)
	if err != nil {
		return errors.NewField("Misbehaviour", err)
	}
	return nil
}

func (obj MisbehaviourMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MisbehaviourMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MisbehaviourMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Misbehaviour`:
	err = decoder.Decode(&obj.Misbehaviour)
	if err != nil {
		return errors.NewField("Misbehaviour", err)
	}
	return nil
}

func (obj *MisbehaviourMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MisbehaviourMsg: %w", err)
	}
	return nil
}

func UnmarshalMisbehaviourMsg(buf []byte) (*MisbehaviourMsg, error) {
	obj := new(MisbehaviourMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateClientMsg struct {
	ClientMessage []byte `json:"clientMessage"`
}

func (obj UpdateClientMsg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientMessage`:
	err = encoder.Encode(obj.ClientMessage)
	if err != nil {
		return errors.NewField("ClientMessage", err)
	}
	return nil
}

func (obj UpdateClientMsg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateClientMsg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateClientMsg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientMessage`:
	err = decoder.Decode(&obj.ClientMessage)
	if err != nil {
		return errors.NewField("ClientMessage", err)
	}
	return nil
}

func (obj *UpdateClientMsg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateClientMsg: %w", err)
	}
	return nil
}

func UnmarshalUpdateClientMsg(buf []byte) (*UpdateClientMsg, error) {
	obj := new(UpdateClientMsg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateResult binary.BorshEnum

const (
	UpdateResult_Update UpdateResult = iota
	UpdateResult_NoOp
)

func (value UpdateResult) String() string {
	switch value {
	case UpdateResult_Update:
		return "Update"
	case UpdateResult_NoOp:
		return "NoOp"
	default:
		return ""
	}
}

// Parameters for uploading a header chunk
type UploadChunkParams struct {
	ChainId      string `json:"chainId"`
	TargetHeight uint64 `json:"targetHeight"`
	ChunkIndex   uint8  `json:"chunkIndex"`
	ChunkData    []byte `json:"chunkData"`
}

func (obj UploadChunkParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ChainId`:
	err = encoder.Encode(obj.ChainId)
	if err != nil {
		return errors.NewField("ChainId", err)
	}
	// Serialize `TargetHeight`:
	err = encoder.Encode(obj.TargetHeight)
	if err != nil {
		return errors.NewField("TargetHeight", err)
	}
	// Serialize `ChunkIndex`:
	err = encoder.Encode(obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Serialize `ChunkData`:
	err = encoder.Encode(obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj UploadChunkParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UploadChunkParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UploadChunkParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ChainId`:
	err = decoder.Decode(&obj.ChainId)
	if err != nil {
		return errors.NewField("ChainId", err)
	}
	// Deserialize `TargetHeight`:
	err = decoder.Decode(&obj.TargetHeight)
	if err != nil {
		return errors.NewField("TargetHeight", err)
	}
	// Deserialize `ChunkIndex`:
	err = decoder.Decode(&obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Deserialize `ChunkData`:
	err = decoder.Decode(&obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj *UploadChunkParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UploadChunkParams: %w", err)
	}
	return nil
}

func UnmarshalUploadChunkParams(buf []byte) (*UploadChunkParams, error) {
	obj := new(UploadChunkParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
