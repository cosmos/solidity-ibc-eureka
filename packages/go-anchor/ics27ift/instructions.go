// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics27_ift

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the IFT application with a new SPL token mint
func NewInitializeInstruction(
	// Params:
	decimalsParam uint8,
	accessManagerParam solanago.PublicKey,
	gmpProgramParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	currentMintAuthorityAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `decimalsParam`:
		err = enc__.Encode(decimalsParam)
		if err != nil {
			return nil, errors.NewField("decimalsParam", err)
		}
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
		// Serialize `gmpProgramParam`:
		err = enc__.Encode(gmpProgramParam)
		if err != nil {
			return nil, errors.NewField("gmpProgramParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// IFT app state PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "mint": Writable, Non-signer, Required
		// SPL Token mint (must already exist, IFT will take mint authority)
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 2 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA - will become the mint authority
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 3 "current_mint_authority": Read-only, Signer, Required
		// Current mint authority (must sign to transfer authority)
		accounts__.Append(solanago.NewAccountMeta(currentMintAuthorityAccount, false, true))
		// Account 4 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "register_ift_bridge" instruction.
// Register an IFT bridge to a counterparty chain
func NewRegisterIftBridgeInstruction(
	// Params:
	msgParam Ics27IftStateRegisterIftBridgeMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RegisterIftBridge[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge PDA (to be created)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "authority": Read-only, Signer, Required
		// Authority with admin role
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_ift_bridge" instruction.
// Remove an IFT bridge
func NewRemoveIftBridgeInstruction(
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge to remove (close and refund rent)
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "authority": Read-only, Signer, Required
		// Authority with admin role
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 4 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "ift_transfer" instruction.
// Initiate an IFT transfer to another chain // Burns tokens and sends GMP call to mint on destination
func NewIftTransferInstruction(
	// Params:
	msgParam Ics27IftStateIftTransferMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	gmpProgramAccount solanago.PublicKey,
	gmpAppStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	gmpIbcAppAccount solanago.PublicKey,
	ibcClientAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftTransfer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Writable, Non-signer, Required
		// IFT bridge for the destination
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "sender_token_account": Writable, Non-signer, Required
		// Sender's token account
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 4 "sender": Read-only, Signer, Required
		// Sender who owns the tokens
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "gmp_program": Read-only, Non-signer, Required
		// GMP program
		accounts__.Append(solanago.NewAccountMeta(gmpProgramAccount, false, false))
		// Account 9 "gmp_app_state": Writable, Non-signer, Required
		// GMP app state PDA
		accounts__.Append(solanago.NewAccountMeta(gmpAppStateAccount, true, false))
		// Account 10 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 11 "router_state": Read-only, Non-signer, Required
		// Router state account
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 12 "client_sequence": Writable, Non-signer, Required
		// Client sequence account for packet sequencing
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 13 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment account to be created
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 14 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 15 "gmp_ibc_app": Read-only, Non-signer, Required
		// GMP's IBC app registration account
		accounts__.Append(solanago.NewAccountMeta(gmpIbcAppAccount, false, false))
		// Account 16 "ibc_client": Read-only, Non-signer, Required
		// IBC client account
		accounts__.Append(solanago.NewAccountMeta(ibcClientAccount, false, false))
		// Account 17 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer account - manually created with runtime-calculated sequence
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ift_mint" instruction.
// Mint IFT tokens (called by GMP when receiving cross-chain transfer)
func NewIftMintInstruction(
	// Params:
	msgParam Ics27IftStateIftMintMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	iftBridgeAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
	receiverOwnerAccount solanago.PublicKey,
	gmpProgramAccount solanago.PublicKey,
	gmpAccountAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IftMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "ift_bridge": Read-only, Non-signer, Required
		// IFT bridge - provides counterparty info for GMP account validation
		accounts__.Append(solanago.NewAccountMeta(iftBridgeAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "receiver_token_account": Writable, Non-signer, Required
		// Receiver's token account (will be created if needed)
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
		// Account 5 "receiver_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverOwnerAccount, false, false))
		// Account 6 "gmp_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(gmpProgramAccount, false, false))
		// Account 7 "gmp_account": Read-only, Signer, Required
		// GMP account PDA - validated to match counterparty bridge
		accounts__.Append(solanago.NewAccountMeta(gmpAccountAccount, false, true))
		// Account 8 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 11 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_acknowledgement_packet" instruction.
// Handle acknowledgement packet (called by router via CPI)
func NewOnAcknowledgementPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnAcknowledgementPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnAcknowledgementPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer to process
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint (for refunds on failure)
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA (for refunds)
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "sender_token_account": Writable, Non-signer, Required
		// Original sender's token account (for refunds)
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 5 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program calling this instruction
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 6 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 7 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_timeout_packet" instruction.
// Handle timeout packet (called by router via CPI)
func NewOnTimeoutPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnTimeoutPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	pendingTransferAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	mintAuthorityAccount solanago.PublicKey,
	senderTokenAccountAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnTimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "pending_transfer": Writable, Non-signer, Required
		// Pending transfer to refund
		accounts__.Append(solanago.NewAccountMeta(pendingTransferAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		// SPL Token mint
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "mint_authority": Read-only, Non-signer, Required
		// Mint authority PDA
		accounts__.Append(solanago.NewAccountMeta(mintAuthorityAccount, false, false))
		// Account 4 "sender_token_account": Writable, Non-signer, Required
		// Original sender's token account
		accounts__.Append(solanago.NewAccountMeta(senderTokenAccountAccount, true, false))
		// Account 5 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program calling this instruction
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 6 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 7 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_access_manager" instruction.
// Set the access manager program (admin only)
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Admin with admin role
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
