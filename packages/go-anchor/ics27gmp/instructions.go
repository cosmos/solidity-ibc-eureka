// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics27_gmp

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the ICS27 GMP application
func NewInitializeInstruction(
	// Params:
	accessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_call" instruction.
// Send a GMP call packet (direct wallet call only)
func NewSendCallInstruction(
	// Params:
	msgParam Ics27GmpStateSendCallMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendCall[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "sender": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 2 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 4 "router_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 5 "client_sequence": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 6 "packet_commitment": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 7 "ibc_app": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 8 "client": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 9 "light_client_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 10 "client_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 11 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 12 "consensus_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
		// Account 13 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_call_cpi" instruction.
// Send a GMP call packet via CPI (program callers only)
func NewSendCallCpiInstruction(
	// Params:
	msgParam Ics27GmpStateSendCallMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendCallCpi[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 3 "router_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 4 "client_sequence": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 5 "packet_commitment": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 6 "ibc_app": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 7 "client": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 8 "light_client_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 9 "client_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 10 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 11 "consensus_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
		// Account 12 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_recv_packet" instruction.
// IBC packet receive handler (called by router via CPI)
func NewOnRecvPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnRecvPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnRecvPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Relayer fee payer - used for account creation rent
		// NOTE: This cannot be the GMP account PDA because PDAs with data cannot
		// be used as payers in System Program transfers. The relayer's fee payer
		// is used for rent, while the GMP account PDA signs via `invoke_signed`.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_acknowledgement_packet" instruction.
// IBC acknowledgement handler (called by router via CPI)
func NewOnAcknowledgementPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnAcknowledgementPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	resultAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnAcknowledgementPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "result_account": Writable, Non-signer, Required
		// Result account storing the acknowledgement (passed as remaining account by router)
		accounts__.Append(solanago.NewAccountMeta(resultAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_timeout_packet" instruction.
// IBC timeout handler (called by router via CPI)
func NewOnTimeoutPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnTimeoutPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	resultAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnTimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "result_account": Writable, Non-signer, Required
		// Result account storing the timeout (passed as remaining account by router)
		accounts__.Append(solanago.NewAccountMeta(resultAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause_app" instruction.
// Pause the entire GMP app (admin only)
func NewPauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PauseApp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unpause_app" instruction.
// Unpause the entire GMP app (admin only)
func NewUnpauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnpauseApp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_access_manager" instruction.
// Set the access manager program (admin only)
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "store_payload_hint" instruction.
// Store a payload hint for ABI-encoded recv packets
func NewStorePayloadHintInstruction(
	// Params:
	dataParam []byte,

	// Accounts:
	hintAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_StorePayloadHint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "hint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(hintAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_payload_hint" instruction.
// Close a payload hint account and refund rent
func NewClosePayloadHintInstruction(
	hintAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClosePayloadHint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "hint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(hintAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
