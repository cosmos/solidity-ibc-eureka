// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics27_gmp

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the ICS27 GMP application
func NewInitializeInstruction(
	// Params:
	accessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_call" instruction.
// Send a GMP call packet
func NewSendCallInstruction(
	// Params:
	msgParam Ics27GmpStateSendCallMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendCall[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "sender": Read-only, Signer, Required
		// Sender of the call
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 2 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program for sending packets
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 4 "router_state": Read-only, Non-signer, Required
		// Router state account
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 5 "client_sequence": Writable, Non-signer, Required
		// Client sequence account for packet sequencing
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 6 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment account to be created
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 7 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for router CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 8 "ibc_app": Read-only, Non-signer, Required
		// IBC app registration account
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 9 "client": Read-only, Non-signer, Required
		// Client account
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 10 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_recv_packet" instruction.
// IBC packet receive handler (called by router via CPI)
func NewOnRecvPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnRecvPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnRecvPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program calling this instruction
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		// Relayer fee payer - used for account creation rent
		// NOTE: This cannot be the GMP account PDA because PDAs with data cannot
		// be used as payers in System Program transfers. The relayer's fee payer
		// is used for rent, while the GMP account PDA signs via `invoke_signed`.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_acknowledgement_packet" instruction.
// IBC acknowledgement handler (called by router via CPI)
func NewOnAcknowledgementPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnAcknowledgementPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnAcknowledgementPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program calling this instruction
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		// Relayer fee payer (passed by router but not used in acknowledgement handler)
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_timeout_packet" instruction.
// IBC timeout handler (called by router via CPI)
func NewOnTimeoutPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnTimeoutPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnTimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// Router program calling this instruction
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 2 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for validating CPI caller
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 3 "payer": Writable, Signer, Required
		// Relayer fee payer (passed by router but not used in timeout handler)
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause_app" instruction.
// Pause the entire GMP app (admin only)
func NewPauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "unpause_app" instruction.
// Unpause the entire GMP app (admin only)
func NewUnpauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// App state account - validated by Anchor PDA constraints
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "set_access_manager" instruction.
// Set the access manager program (admin only)
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar for CPI validation
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
