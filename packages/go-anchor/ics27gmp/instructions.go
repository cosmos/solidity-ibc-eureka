// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics27_gmp

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
// Initialize the ICS27 GMP application
func NewInitializeInstruction(
	// Params:
	accessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA, created with a fixed seed.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		// Fee payer that funds the `app_state` account creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account allocation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_call" instruction.
// Send a GMP call packet (direct wallet call only)
func NewSendCallInstruction(
	// Params:
	msgParam Ics27GmpStateSendCallMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	senderAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendCall[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA. Must not be paused.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "sender": Read-only, Signer, Required
		// Wallet that initiates the cross-chain call, recorded as the packet sender.
		accounts__.Append(solanago.NewAccountMeta(senderAccount, false, true))
		// Account 2 "payer": Writable, Signer, Required
		// Fee payer for the packet commitment account creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// ICS26 router program invoked via CPI to submit the packet.
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 4 "router_state": Read-only, Non-signer, Required
		// Router's global state PDA, forwarded to the router CPI.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 5 "client_sequence": Writable, Non-signer, Required
		// Packet sequence counter for the source client, incremented by the router.
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 6 "packet_commitment": Writable, Non-signer, Required
		// Stores the packet commitment hash after the router processes the packet.
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 7 "ibc_app": Read-only, Non-signer, Required
		// Port-to-program mapping that authorizes this GMP program for the GMP port.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 8 "client": Read-only, Non-signer, Required
		// IBC client account that identifies the destination chain for routing.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 9 "light_client_program": Read-only, Non-signer, Required
		// Light client program used by the router to check client status.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 10 "client_state": Read-only, Non-signer, Required
		// Light client's state account, forwarded to the router for status verification.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 11 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to reject CPI callers (direct-call-only enforcement).
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 12 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account, forwarded to the router for client expiry check.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
		// Account 13 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account allocation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_call_cpi" instruction.
// Send a GMP call packet via CPI (program callers only)
func NewSendCallCpiInstruction(
	// Params:
	msgParam Ics27GmpStateSendCallMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	routerProgramAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendCallCpi[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA. Must not be paused.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		// Fee payer for the packet commitment account creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "router_program": Read-only, Non-signer, Required, Address: FRGF7cthWUvDvAHMUARUHFycyUK2VDUtBchmkwrz7hgx
		// ICS26 router program invoked via CPI to submit the packet.
		accounts__.Append(solanago.NewAccountMeta(routerProgramAccount, false, false))
		// Account 3 "router_state": Read-only, Non-signer, Required
		// Router's global state PDA, forwarded to the router CPI.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 4 "client_sequence": Writable, Non-signer, Required
		// Packet sequence counter for the source client, incremented by the router.
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 5 "packet_commitment": Writable, Non-signer, Required
		// Stores the packet commitment hash after the router processes the packet.
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 6 "ibc_app": Read-only, Non-signer, Required
		// Port-to-program mapping that authorizes this GMP program for the GMP port.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 7 "client": Read-only, Non-signer, Required
		// IBC client account that identifies the destination chain for routing.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 8 "light_client_program": Read-only, Non-signer, Required
		// Light client program used by the router to check client status.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 9 "client_state": Read-only, Non-signer, Required
		// Light client's state account, forwarded to the router for status verification.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 10 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to enforce single-level CPI and extract the caller program ID.
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 11 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account, forwarded to the router for client expiry check.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
		// Account 12 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account allocation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_recv_packet" instruction.
// IBC packet receive handler (called by router via CPI)
func NewOnRecvPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnRecvPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnRecvPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA. Must not be paused.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to verify the CPI caller is the authorized router.
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Relayer-provided fee payer used for account creation rent.
		// NOTE: This cannot be the GMP account PDA because PDAs with data cannot
		// be used as payers in System Program transfers. The relayer's fee payer
		// is used for rent, while the GMP account PDA signs via `invoke_signed`.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account allocation during target CPI.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_acknowledgement_packet" instruction.
// IBC acknowledgement handler (called by router via CPI)
func NewOnAcknowledgementPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnAcknowledgementPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	resultAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnAcknowledgementPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// GMP program's global configuration PDA. Must not be paused.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to verify the CPI caller is the authorized router.
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Fee payer that funds the `result_account` creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// Solana system program used for `result_account` allocation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "result_account": Writable, Non-signer, Required
		// Newly created PDA that stores the acknowledgement commitment and metadata,
		// keyed by `source_client` and `sequence`.
		accounts__.Append(solanago.NewAccountMeta(resultAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "on_timeout_packet" instruction.
// IBC timeout handler (called by router via CPI)
func NewOnTimeoutPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesAppMsgsOnTimeoutPacketMsg,

	// Accounts:
	appStateAccount solanago.PublicKey,
	instructionSysvarAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	resultAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OnTimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Read-only, Non-signer, Required
		// GMP program's global configuration PDA. Must not be paused.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, false, false))
		// Account 1 "instruction_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to verify the CPI caller is the authorized router.
		accounts__.Append(solanago.NewAccountMeta(instructionSysvarAccount, false, false))
		// Account 2 "payer": Writable, Signer, Required
		// Fee payer that funds the `result_account` creation.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		// Solana system program used for `result_account` allocation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "result_account": Writable, Non-signer, Required
		// Newly created PDA that stores the timeout status and metadata,
		// keyed by `source_client` and `sequence`.
		accounts__.Append(solanago.NewAccountMeta(resultAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause_app" instruction.
// Pause the entire GMP app (admin only)
func NewPauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PauseApp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA that holds the paused flag.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Access manager account used for role-based authorization.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		// Signer whose `PAUSER_ROLE` membership is verified by the access manager.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to detect and reject unauthorized CPI callers.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unpause_app" instruction.
// Unpause the entire GMP app (admin only)
func NewUnpauseAppInstruction(
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnpauseApp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA that holds the paused flag.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Access manager account used for role-based authorization.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		// Signer whose `UNPAUSER_ROLE` membership is verified by the access manager.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to detect and reject unauthorized CPI callers.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_access_manager" instruction.
// Set the access manager program (admin only)
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	appStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "app_state": Writable, Non-signer, Required
		// GMP program's global configuration PDA whose `access_manager` field will be updated.
		accounts__.Append(solanago.NewAccountMeta(appStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Current access manager account used to verify admin privileges.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Signer whose admin membership is verified by the current access manager.
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used to detect and reject unauthorized CPI callers.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
