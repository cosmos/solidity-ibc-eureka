// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ics26_router

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	accessManagerParam solanago.PublicKey,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `accessManagerParam`:
		err = enc__.Encode(accessManagerParam)
		if err != nil {
			return nil, errors.NewField("accessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Writable, Non-signer, Required
		// Global router configuration PDA storing the access manager address.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, true, false))
		// Account 1 "payer": Writable, Signer, Required
		// Pays for creating the `RouterState` account.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_ibc_app" instruction.
func NewAddIbcAppInstruction(
	// Params:
	portIdParam string,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	appProgramAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddIbcApp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `portIdParam`:
		err = enc__.Encode(portIdParam)
		if err != nil {
			return nil, errors.NewField("portIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "ibc_app": Writable, Non-signer, Required
		// PDA mapping `port_id` to its IBC application program.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, true, false))
		// Account 3 "app_program": Read-only, Non-signer, Required
		// IBC application program to register for this port.
		accounts__.Append(solanago.NewAccountMeta(appProgramAccount, false, false))
		// Account 4 "payer": Writable, Signer, Required
		// Pays for creating the `IBCApp` account.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 5 "authority": Read-only, Signer, Required
		// Signer with the `ID_CUSTOMIZER_ROLE`; stored as the app authority.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "send_packet" instruction.
func NewSendPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgSendPacket,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	appSignerAccount solanago.PublicKey,
	payerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "ibc_app": Read-only, Non-signer, Required
		// PDA mapping the source port to its registered IBC application.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 2 "client_sequence": Writable, Non-signer, Required
		// Mutable sequence counter for this client; incremented on each send.
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 3 "packet_commitment": Writable, Non-signer, Required
		// Stores the packet commitment hash. Created manually because the
		// sequence is computed at runtime via `calculate_namespaced_sequence`.
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 4 "app_signer": Read-only, Signer, Required
		// PDA signed by the calling IBC app program, proving it authorized this send.
		accounts__.Append(solanago.NewAccountMeta(appSignerAccount, false, true))
		// Account 5 "payer": Writable, Signer, Required
		// Pays rent for the new `packet_commitment` account.
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "client": Read-only, Non-signer, Required
		// Client PDA for the source client; must be active.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 8 "light_client_program": Read-only, Non-signer, Required
		// Light client program used to query client status before sending.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 9 "client_state": Read-only, Non-signer, Required
		// Client state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 10 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account owned by the light client program (for expiry check).
		// light client program itself validates it.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "recv_packet" instruction.
func NewRecvPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgRecvPacket,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	packetReceiptAccount solanago.PublicKey,
	packetAckAccount solanago.PublicKey,
	ibcAppProgramAccount solanago.PublicKey,
	ibcAppStateAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RecvPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "ibc_app": Read-only, Non-signer, Required
		// PDA mapping the destination port to its registered IBC application.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 3 "packet_receipt": Writable, Non-signer, Required
		// Stores the packet receipt commitment; created on first receive.
		accounts__.Append(solanago.NewAccountMeta(packetReceiptAccount, true, false))
		// Account 4 "packet_ack": Writable, Non-signer, Required
		// Stores the packet acknowledgement commitment after app callback.
		accounts__.Append(solanago.NewAccountMeta(packetAckAccount, true, false))
		// Account 5 "ibc_app_program": Read-only, Non-signer, Required
		// IBC application program to deliver the packet to via CPI.
		accounts__.Append(solanago.NewAccountMeta(ibcAppProgramAccount, false, false))
		// Account 6 "ibc_app_state": Writable, Non-signer, Required
		// Mutable state account of the IBC application (passed into the CPI).
		accounts__.Append(solanago.NewAccountMeta(ibcAppStateAccount, true, false))
		// Account 7 "relayer": Writable, Signer, Required
		// Relayer submitting the packet; must hold the `RELAYER_ROLE` and pays rent.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 8 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 10 "client": Read-only, Non-signer, Required
		// Client PDA for the destination client; must be active.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 11 "light_client_program": Read-only, Non-signer, Required
		// Light client program used to verify the membership proof.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 12 "client_state": Read-only, Non-signer, Required
		// Client state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 13 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ack_packet" instruction.
func NewAckPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgAckPacket,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppProgramAccount solanago.PublicKey,
	ibcAppStateAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AckPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "ibc_app": Read-only, Non-signer, Required
		// PDA mapping the source port to its registered IBC application.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 3 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment PDA; closed after successful acknowledgement and
		// its rent is returned to the relayer.
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 4 "ibc_app_program": Read-only, Non-signer, Required
		// IBC application program to notify via CPI.
		accounts__.Append(solanago.NewAccountMeta(ibcAppProgramAccount, false, false))
		// Account 5 "ibc_app_state": Writable, Non-signer, Required
		// Mutable state account of the IBC application (passed into the CPI).
		accounts__.Append(solanago.NewAccountMeta(ibcAppStateAccount, true, false))
		// Account 6 "relayer": Writable, Signer, Required
		// Relayer submitting the acknowledgement; must hold the `RELAYER_ROLE`.
		// Receives rent from the closed `packet_commitment` account.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// Solana system program required by Anchor.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 9 "client": Read-only, Non-signer, Required
		// Client PDA for the source client; must be active.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 10 "light_client_program": Read-only, Non-signer, Required
		// Light client program used to verify the acknowledgement proof.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 11 "client_state": Read-only, Non-signer, Required
		// Client state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 12 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "timeout_packet" instruction.
func NewTimeoutPacketInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgTimeoutPacket,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	ibcAppAccount solanago.PublicKey,
	packetCommitmentAccount solanago.PublicKey,
	ibcAppProgramAccount solanago.PublicKey,
	ibcAppStateAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	clientStateAccount solanago.PublicKey,
	consensusStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TimeoutPacket[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "ibc_app": Read-only, Non-signer, Required
		// PDA mapping the source port to its registered IBC application.
		accounts__.Append(solanago.NewAccountMeta(ibcAppAccount, false, false))
		// Account 3 "packet_commitment": Writable, Non-signer, Required
		// Packet commitment PDA; closed after successful timeout and its rent
		// is returned to the relayer.
		accounts__.Append(solanago.NewAccountMeta(packetCommitmentAccount, true, false))
		// Account 4 "ibc_app_program": Read-only, Non-signer, Required
		// IBC application program to notify via CPI.
		accounts__.Append(solanago.NewAccountMeta(ibcAppProgramAccount, false, false))
		// Account 5 "ibc_app_state": Writable, Non-signer, Required
		// Mutable state account of the IBC application (passed into the CPI).
		accounts__.Append(solanago.NewAccountMeta(ibcAppStateAccount, true, false))
		// Account 6 "relayer": Writable, Signer, Required
		// Relayer submitting the timeout; must hold the `RELAYER_ROLE`.
		// Receives rent from the closed `packet_commitment` account.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		// Solana system program required by Anchor.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
		// Account 9 "client": Read-only, Non-signer, Required
		// Client PDA for the source client; must be active.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, false, false))
		// Account 10 "light_client_program": Read-only, Non-signer, Required
		// Light client program used to verify the non-membership proof.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 11 "client_state": Read-only, Non-signer, Required
		// Client state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(clientStateAccount, false, false))
		// Account 12 "consensus_state": Read-only, Non-signer, Required
		// Consensus state account owned by the light client program.
		accounts__.Append(solanago.NewAccountMeta(consensusStateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_client" instruction.
func NewAddClientInstruction(
	// Params:
	clientIdParam string,
	counterpartyInfoParam SolanaIbcTypesRouterCounterpartyInfo,

	// Accounts:
	authorityAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	clientSequenceAccount solanago.PublicKey,
	lightClientProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddClient[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
		// Serialize `counterpartyInfoParam`:
		err = enc__.Encode(counterpartyInfoParam)
		if err != nil {
			return nil, errors.NewField("counterpartyInfoParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Writable, Signer, Required
		// Signer with the `ID_CUSTOMIZER_ROLE`; also pays for account creation.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 1 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "client": Writable, Non-signer, Required
		// PDA mapping `client_id` to its light client program and counterparty info.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, true, false))
		// Account 4 "client_sequence": Writable, Non-signer, Required
		// PDA tracking the next send-side packet sequence for this client.
		accounts__.Append(solanago.NewAccountMeta(clientSequenceAccount, true, false))
		// Account 5 "light_client_program": Read-only, Non-signer, Required
		// Light client program to associate with this client.
		accounts__.Append(solanago.NewAccountMeta(lightClientProgramAccount, false, false))
		// Account 6 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "migrate_client" instruction.
func NewMigrateClientInstruction(
	// Params:
	clientIdParam string,
	paramsParam Ics26RouterInstructionsClientMigrateClientParams,

	// Accounts:
	authorityAccount solanago.PublicKey,
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	clientAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_MigrateClient[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `clientIdParam`:
		err = enc__.Encode(clientIdParam)
		if err != nil {
			return nil, errors.NewField("clientIdParam", err)
		}
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Writable, Signer, Required
		// Admin signer authorized to migrate clients.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 1 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 2 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for admin verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 3 "client": Writable, Non-signer, Required
		// Mutable client PDA whose fields will be updated.
		accounts__.Append(solanago.NewAccountMeta(clientAccount, true, false))
		// Account 4 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "upload_payload_chunk" instruction.
func NewUploadPayloadChunkInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgUploadChunk,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	chunkAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UploadPayloadChunk[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "chunk": Writable, Non-signer, Required
		// Temporary storage for one payload chunk, keyed by relayer, client,
		// sequence, payload index and chunk index.
		accounts__.Append(solanago.NewAccountMeta(chunkAccount, true, false))
		// Account 3 "relayer": Writable, Signer, Required
		// Relayer uploading the chunk; must hold the `RELAYER_ROLE` and pays rent.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "upload_proof_chunk" instruction.
func NewUploadProofChunkInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgUploadChunk,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	chunkAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UploadProofChunk[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "chunk": Writable, Non-signer, Required
		// Temporary storage for one proof chunk, keyed by relayer, client,
		// sequence and chunk index.
		accounts__.Append(solanago.NewAccountMeta(chunkAccount, true, false))
		// Account 3 "relayer": Writable, Signer, Required
		// Relayer uploading the chunk; must hold the `RELAYER_ROLE` and pays rent.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		// Solana system program used for account creation.
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cleanup_chunks" instruction.
func NewCleanupChunksInstruction(
	// Params:
	msgParam SolanaIbcTypesRouterMsgCleanupChunks,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	relayerAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CleanupChunks[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `msgParam`:
		err = enc__.Encode(msgParam)
		if err != nil {
			return nil, errors.NewField("msgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Read-only, Non-signer, Required
		// Global router configuration PDA.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, false, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Global access control state used for relayer role verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "relayer": Writable, Signer, Required
		// Relayer reclaiming rent; must hold the `RELAYER_ROLE`.
		// Receives lamports from closed chunk accounts.
		accounts__.Append(solanago.NewAccountMeta(relayerAccount, true, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_access_manager" instruction.
func NewSetAccessManagerInstruction(
	// Params:
	newAccessManagerParam solanago.PublicKey,

	// Accounts:
	routerStateAccount solanago.PublicKey,
	accessManagerAccount solanago.PublicKey,
	adminAccount solanago.PublicKey,
	instructionsSysvarAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetAccessManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAccessManagerParam`:
		err = enc__.Encode(newAccessManagerParam)
		if err != nil {
			return nil, errors.NewField("newAccessManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "router_state": Writable, Non-signer, Required
		// Mutable global router configuration PDA whose `access_manager` field
		// will be updated.
		accounts__.Append(solanago.NewAccountMeta(routerStateAccount, true, false))
		// Account 1 "access_manager": Read-only, Non-signer, Required
		// Current access control state used for admin verification.
		accounts__.Append(solanago.NewAccountMeta(accessManagerAccount, false, false))
		// Account 2 "admin": Read-only, Signer, Required
		// Admin signer authorized to change the access manager.
		accounts__.Append(solanago.NewAccountMeta(adminAccount, false, true))
		// Account 3 "instructions_sysvar": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		// Instructions sysvar used for CPI detection.
		accounts__.Append(solanago.NewAccountMeta(instructionsSysvarAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
