// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ics26_router

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Account schema version
type AccountVersion binary.BorshEnum

const (
	AccountVersion_V1 AccountVersion = iota
)

func (value AccountVersion) String() string {
	switch value {
	case AccountVersion_V1:
		return "V1"
	default:
		return ""
	}
}

// Client mapping client IDs to light client program IDs
type Client struct {
	// Schema version for upgrades
	Version AccountVersion `json:"version"`

	// The client identifier
	ClientId string `json:"clientId"`

	// The program ID of the light client
	ClientProgramId solanago.PublicKey `json:"clientProgramId"`

	// Counterparty chain information
	CounterpartyInfo CounterpartyInfo `json:"counterpartyInfo"`

	// Authority that registered this client
	Authority solanago.PublicKey `json:"authority"`

	// Whether the client is active
	Active bool `json:"active"`

	// Reserved space for future fields
	Reserved [256]uint8 `json:"reserved"`
}

func (obj Client) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `ClientProgramId`:
	err = encoder.Encode(obj.ClientProgramId)
	if err != nil {
		return errors.NewField("ClientProgramId", err)
	}
	// Serialize `CounterpartyInfo`:
	err = encoder.Encode(obj.CounterpartyInfo)
	if err != nil {
		return errors.NewField("CounterpartyInfo", err)
	}
	// Serialize `Authority`:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Serialize `Active`:
	err = encoder.Encode(obj.Active)
	if err != nil {
		return errors.NewField("Active", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj Client) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Client: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Client) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `ClientProgramId`:
	err = decoder.Decode(&obj.ClientProgramId)
	if err != nil {
		return errors.NewField("ClientProgramId", err)
	}
	// Deserialize `CounterpartyInfo`:
	err = decoder.Decode(&obj.CounterpartyInfo)
	if err != nil {
		return errors.NewField("CounterpartyInfo", err)
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Deserialize `Active`:
	err = decoder.Decode(&obj.Active)
	if err != nil {
		return errors.NewField("Active", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *Client) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Client: %w", err)
	}
	return nil
}

func UnmarshalClient(buf []byte) (*Client, error) {
	obj := new(Client)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Client sequence tracking
type ClientSequence struct {
	// Schema version for upgrades
	Version AccountVersion `json:"version"`

	// Next sequence number for sending packets
	NextSequenceSend uint64 `json:"nextSequenceSend"`

	// Reserved space for future fields
	Reserved [256]uint8 `json:"reserved"`
}

func (obj ClientSequence) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `NextSequenceSend`:
	err = encoder.Encode(obj.NextSequenceSend)
	if err != nil {
		return errors.NewField("NextSequenceSend", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj ClientSequence) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ClientSequence: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ClientSequence) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `NextSequenceSend`:
	err = decoder.Decode(&obj.NextSequenceSend)
	if err != nil {
		return errors.NewField("NextSequenceSend", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *ClientSequence) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClientSequence: %w", err)
	}
	return nil
}

func UnmarshalClientSequence(buf []byte) (*ClientSequence, error) {
	obj := new(ClientSequence)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Commitment storage (simple key-value)
type Commitment struct {
	// The commitment value (sha256 hash)
	Value [32]uint8 `json:"value"`
}

func (obj Commitment) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Value`:
	err = encoder.Encode(obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj Commitment) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Commitment: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Commitment) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Value`:
	err = decoder.Decode(&obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj *Commitment) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Commitment: %w", err)
	}
	return nil
}

func UnmarshalCommitment(buf []byte) (*Commitment, error) {
	obj := new(Commitment)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Counterparty chain information
type CounterpartyInfo struct {
	// Client ID on the counterparty chain
	ClientId string `json:"clientId"`

	// Merkle prefix for proof verification
	MerklePrefix [][]byte `json:"merklePrefix"`
}

func (obj CounterpartyInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `MerklePrefix`:
	err = encoder.Encode(obj.MerklePrefix)
	if err != nil {
		return errors.NewField("MerklePrefix", err)
	}
	return nil
}

func (obj CounterpartyInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CounterpartyInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CounterpartyInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `MerklePrefix`:
	err = decoder.Decode(&obj.MerklePrefix)
	if err != nil {
		return errors.NewField("MerklePrefix", err)
	}
	return nil
}

func (obj *CounterpartyInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CounterpartyInfo: %w", err)
	}
	return nil
}

func UnmarshalCounterpartyInfo(buf []byte) (*CounterpartyInfo, error) {
	obj := new(CounterpartyInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// `IBCApp` mapping port IDs to IBC app program IDs
type IbcApp struct {
	// Schema version for upgrades
	Version AccountVersion `json:"version"`

	// The port identifier
	PortId string `json:"portId"`

	// The program ID of the IBC application
	AppProgramId solanago.PublicKey `json:"appProgramId"`

	// Authority that registered this port
	Authority solanago.PublicKey `json:"authority"`

	// Reserved space for future fields
	Reserved [256]uint8 `json:"reserved"`
}

func (obj IbcApp) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `PortId`:
	err = encoder.Encode(obj.PortId)
	if err != nil {
		return errors.NewField("PortId", err)
	}
	// Serialize `AppProgramId`:
	err = encoder.Encode(obj.AppProgramId)
	if err != nil {
		return errors.NewField("AppProgramId", err)
	}
	// Serialize `Authority`:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj IbcApp) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IbcApp: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IbcApp) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `PortId`:
	err = decoder.Decode(&obj.PortId)
	if err != nil {
		return errors.NewField("PortId", err)
	}
	// Deserialize `AppProgramId`:
	err = decoder.Decode(&obj.AppProgramId)
	if err != nil {
		return errors.NewField("AppProgramId", err)
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *IbcApp) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IbcApp: %w", err)
	}
	return nil
}

func UnmarshalIbcApp(buf []byte) (*IbcApp, error) {
	obj := new(IbcApp)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for acknowledging a packet
type MsgAckPacket struct {
	Packet          Packet            `json:"packet"`
	Payloads        []PayloadMetadata `json:"payloads"`
	Acknowledgement []byte            `json:"acknowledgement"`
	Proof           ProofMetadata     `json:"proof"`
}

func (obj MsgAckPacket) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Packet`:
	err = encoder.Encode(obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Serialize `Payloads`:
	err = encoder.Encode(obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Serialize `Acknowledgement`:
	err = encoder.Encode(obj.Acknowledgement)
	if err != nil {
		return errors.NewField("Acknowledgement", err)
	}
	// Serialize `Proof`:
	err = encoder.Encode(obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj MsgAckPacket) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgAckPacket: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgAckPacket) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Packet`:
	err = decoder.Decode(&obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Deserialize `Payloads`:
	err = decoder.Decode(&obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Deserialize `Acknowledgement`:
	err = decoder.Decode(&obj.Acknowledgement)
	if err != nil {
		return errors.NewField("Acknowledgement", err)
	}
	// Deserialize `Proof`:
	err = decoder.Decode(&obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj *MsgAckPacket) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgAckPacket: %w", err)
	}
	return nil
}

func UnmarshalMsgAckPacket(buf []byte) (*MsgAckPacket, error) {
	obj := new(MsgAckPacket)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for cleanup
type MsgCleanupChunks struct {
	ClientId         string `json:"clientId"`
	Sequence         uint64 `json:"sequence"`
	PayloadChunks    []byte `json:"payloadChunks"`
	TotalProofChunks uint8  `json:"totalProofChunks"`
}

func (obj MsgCleanupChunks) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `PayloadChunks`:
	err = encoder.Encode(obj.PayloadChunks)
	if err != nil {
		return errors.NewField("PayloadChunks", err)
	}
	// Serialize `TotalProofChunks`:
	err = encoder.Encode(obj.TotalProofChunks)
	if err != nil {
		return errors.NewField("TotalProofChunks", err)
	}
	return nil
}

func (obj MsgCleanupChunks) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgCleanupChunks: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgCleanupChunks) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `PayloadChunks`:
	err = decoder.Decode(&obj.PayloadChunks)
	if err != nil {
		return errors.NewField("PayloadChunks", err)
	}
	// Deserialize `TotalProofChunks`:
	err = decoder.Decode(&obj.TotalProofChunks)
	if err != nil {
		return errors.NewField("TotalProofChunks", err)
	}
	return nil
}

func (obj *MsgCleanupChunks) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgCleanupChunks: %w", err)
	}
	return nil
}

func UnmarshalMsgCleanupChunks(buf []byte) (*MsgCleanupChunks, error) {
	obj := new(MsgCleanupChunks)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for receiving a packet
type MsgRecvPacket struct {
	Packet   Packet            `json:"packet"`
	Payloads []PayloadMetadata `json:"payloads"`
	Proof    ProofMetadata     `json:"proof"`
}

func (obj MsgRecvPacket) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Packet`:
	err = encoder.Encode(obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Serialize `Payloads`:
	err = encoder.Encode(obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Serialize `Proof`:
	err = encoder.Encode(obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj MsgRecvPacket) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgRecvPacket: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgRecvPacket) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Packet`:
	err = decoder.Decode(&obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Deserialize `Payloads`:
	err = decoder.Decode(&obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Deserialize `Proof`:
	err = decoder.Decode(&obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj *MsgRecvPacket) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgRecvPacket: %w", err)
	}
	return nil
}

func UnmarshalMsgRecvPacket(buf []byte) (*MsgRecvPacket, error) {
	obj := new(MsgRecvPacket)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for sending a packet
type MsgSendPacket struct {
	SourceClient     string  `json:"sourceClient"`
	TimeoutTimestamp int64   `json:"timeoutTimestamp"`
	Payload          Payload `json:"payload"`
}

func (obj MsgSendPacket) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceClient`:
	err = encoder.Encode(obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Serialize `TimeoutTimestamp`:
	err = encoder.Encode(obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	// Serialize `Payload`:
	err = encoder.Encode(obj.Payload)
	if err != nil {
		return errors.NewField("Payload", err)
	}
	return nil
}

func (obj MsgSendPacket) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgSendPacket: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgSendPacket) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceClient`:
	err = decoder.Decode(&obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Deserialize `TimeoutTimestamp`:
	err = decoder.Decode(&obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	// Deserialize `Payload`:
	err = decoder.Decode(&obj.Payload)
	if err != nil {
		return errors.NewField("Payload", err)
	}
	return nil
}

func (obj *MsgSendPacket) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgSendPacket: %w", err)
	}
	return nil
}

func UnmarshalMsgSendPacket(buf []byte) (*MsgSendPacket, error) {
	obj := new(MsgSendPacket)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for timing out a packet
type MsgTimeoutPacket struct {
	Packet   Packet            `json:"packet"`
	Payloads []PayloadMetadata `json:"payloads"`
	Proof    ProofMetadata     `json:"proof"`
}

func (obj MsgTimeoutPacket) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Packet`:
	err = encoder.Encode(obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Serialize `Payloads`:
	err = encoder.Encode(obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Serialize `Proof`:
	err = encoder.Encode(obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj MsgTimeoutPacket) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgTimeoutPacket: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgTimeoutPacket) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Packet`:
	err = decoder.Decode(&obj.Packet)
	if err != nil {
		return errors.NewField("Packet", err)
	}
	// Deserialize `Payloads`:
	err = decoder.Decode(&obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	// Deserialize `Proof`:
	err = decoder.Decode(&obj.Proof)
	if err != nil {
		return errors.NewField("Proof", err)
	}
	return nil
}

func (obj *MsgTimeoutPacket) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgTimeoutPacket: %w", err)
	}
	return nil
}

func UnmarshalMsgTimeoutPacket(buf []byte) (*MsgTimeoutPacket, error) {
	obj := new(MsgTimeoutPacket)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Message for uploading chunks
type MsgUploadChunk struct {
	ClientId     string `json:"clientId"`
	Sequence     uint64 `json:"sequence"`
	PayloadIndex uint8  `json:"payloadIndex"`
	ChunkIndex   uint8  `json:"chunkIndex"`
	ChunkData    []byte `json:"chunkData"`
}

func (obj MsgUploadChunk) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `PayloadIndex`:
	err = encoder.Encode(obj.PayloadIndex)
	if err != nil {
		return errors.NewField("PayloadIndex", err)
	}
	// Serialize `ChunkIndex`:
	err = encoder.Encode(obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Serialize `ChunkData`:
	err = encoder.Encode(obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj MsgUploadChunk) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MsgUploadChunk: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MsgUploadChunk) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `PayloadIndex`:
	err = decoder.Decode(&obj.PayloadIndex)
	if err != nil {
		return errors.NewField("PayloadIndex", err)
	}
	// Deserialize `ChunkIndex`:
	err = decoder.Decode(&obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Deserialize `ChunkData`:
	err = decoder.Decode(&obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj *MsgUploadChunk) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MsgUploadChunk: %w", err)
	}
	return nil
}

func UnmarshalMsgUploadChunk(buf []byte) (*MsgUploadChunk, error) {
	obj := new(MsgUploadChunk)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Packet structure matching Ethereum's ICS26RouterMsgs.Packet
type Packet struct {
	Sequence         uint64    `json:"sequence"`
	SourceClient     string    `json:"sourceClient"`
	DestClient       string    `json:"destClient"`
	TimeoutTimestamp int64     `json:"timeoutTimestamp"`
	Payloads         []Payload `json:"payloads"`
}

func (obj Packet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `SourceClient`:
	err = encoder.Encode(obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Serialize `DestClient`:
	err = encoder.Encode(obj.DestClient)
	if err != nil {
		return errors.NewField("DestClient", err)
	}
	// Serialize `TimeoutTimestamp`:
	err = encoder.Encode(obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	// Serialize `Payloads`:
	err = encoder.Encode(obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	return nil
}

func (obj Packet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Packet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Packet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `SourceClient`:
	err = decoder.Decode(&obj.SourceClient)
	if err != nil {
		return errors.NewField("SourceClient", err)
	}
	// Deserialize `DestClient`:
	err = decoder.Decode(&obj.DestClient)
	if err != nil {
		return errors.NewField("DestClient", err)
	}
	// Deserialize `TimeoutTimestamp`:
	err = decoder.Decode(&obj.TimeoutTimestamp)
	if err != nil {
		return errors.NewField("TimeoutTimestamp", err)
	}
	// Deserialize `Payloads`:
	err = decoder.Decode(&obj.Payloads)
	if err != nil {
		return errors.NewField("Payloads", err)
	}
	return nil
}

func (obj *Packet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Packet: %w", err)
	}
	return nil
}

func UnmarshalPacket(buf []byte) (*Packet, error) {
	obj := new(Packet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Payload structure shared between router and IBC apps
type Payload struct {
	SourcePort string `json:"sourcePort"`
	DestPort   string `json:"destPort"`
	Version    string `json:"version"`
	Encoding   string `json:"encoding"`
	Value      []byte `json:"value"`
}

func (obj Payload) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourcePort`:
	err = encoder.Encode(obj.SourcePort)
	if err != nil {
		return errors.NewField("SourcePort", err)
	}
	// Serialize `DestPort`:
	err = encoder.Encode(obj.DestPort)
	if err != nil {
		return errors.NewField("DestPort", err)
	}
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Encoding`:
	err = encoder.Encode(obj.Encoding)
	if err != nil {
		return errors.NewField("Encoding", err)
	}
	// Serialize `Value`:
	err = encoder.Encode(obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj Payload) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Payload: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Payload) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourcePort`:
	err = decoder.Decode(&obj.SourcePort)
	if err != nil {
		return errors.NewField("SourcePort", err)
	}
	// Deserialize `DestPort`:
	err = decoder.Decode(&obj.DestPort)
	if err != nil {
		return errors.NewField("DestPort", err)
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Encoding`:
	err = decoder.Decode(&obj.Encoding)
	if err != nil {
		return errors.NewField("Encoding", err)
	}
	// Deserialize `Value`:
	err = decoder.Decode(&obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj *Payload) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Payload: %w", err)
	}
	return nil
}

func UnmarshalPayload(buf []byte) (*Payload, error) {
	obj := new(Payload)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Storage for payload chunks during multi-transaction upload
type PayloadChunk struct {
	// Client ID this chunk belongs to
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Index of the payload this chunk belongs to (for multi-payload packets)
	PayloadIndex uint8 `json:"payloadIndex"`

	// Index of this chunk (0-based)
	ChunkIndex uint8 `json:"chunkIndex"`

	// The chunk data
	ChunkData []byte `json:"chunkData"`
}

func (obj PayloadChunk) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `PayloadIndex`:
	err = encoder.Encode(obj.PayloadIndex)
	if err != nil {
		return errors.NewField("PayloadIndex", err)
	}
	// Serialize `ChunkIndex`:
	err = encoder.Encode(obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Serialize `ChunkData`:
	err = encoder.Encode(obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj PayloadChunk) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadChunk: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadChunk) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `PayloadIndex`:
	err = decoder.Decode(&obj.PayloadIndex)
	if err != nil {
		return errors.NewField("PayloadIndex", err)
	}
	// Deserialize `ChunkIndex`:
	err = decoder.Decode(&obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Deserialize `ChunkData`:
	err = decoder.Decode(&obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj *PayloadChunk) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadChunk: %w", err)
	}
	return nil
}

func UnmarshalPayloadChunk(buf []byte) (*PayloadChunk, error) {
	obj := new(PayloadChunk)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Payload metadata for chunked operations
type PayloadMetadata struct {
	SourcePort  string `json:"sourcePort"`
	DestPort    string `json:"destPort"`
	Version     string `json:"version"`
	Encoding    string `json:"encoding"`
	TotalChunks uint8  `json:"totalChunks"`
}

func (obj PayloadMetadata) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourcePort`:
	err = encoder.Encode(obj.SourcePort)
	if err != nil {
		return errors.NewField("SourcePort", err)
	}
	// Serialize `DestPort`:
	err = encoder.Encode(obj.DestPort)
	if err != nil {
		return errors.NewField("DestPort", err)
	}
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Encoding`:
	err = encoder.Encode(obj.Encoding)
	if err != nil {
		return errors.NewField("Encoding", err)
	}
	// Serialize `TotalChunks`:
	err = encoder.Encode(obj.TotalChunks)
	if err != nil {
		return errors.NewField("TotalChunks", err)
	}
	return nil
}

func (obj PayloadMetadata) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadMetadata: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadMetadata) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourcePort`:
	err = decoder.Decode(&obj.SourcePort)
	if err != nil {
		return errors.NewField("SourcePort", err)
	}
	// Deserialize `DestPort`:
	err = decoder.Decode(&obj.DestPort)
	if err != nil {
		return errors.NewField("DestPort", err)
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Encoding`:
	err = decoder.Decode(&obj.Encoding)
	if err != nil {
		return errors.NewField("Encoding", err)
	}
	// Deserialize `TotalChunks`:
	err = decoder.Decode(&obj.TotalChunks)
	if err != nil {
		return errors.NewField("TotalChunks", err)
	}
	return nil
}

func (obj *PayloadMetadata) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadMetadata: %w", err)
	}
	return nil
}

func UnmarshalPayloadMetadata(buf []byte) (*PayloadMetadata, error) {
	obj := new(PayloadMetadata)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Storage for proof chunks during multi-transaction upload
type ProofChunk struct {
	// Client ID this chunk belongs to
	ClientId string `json:"clientId"`

	// Packet sequence number
	Sequence uint64 `json:"sequence"`

	// Index of this chunk (0-based)
	ChunkIndex uint8 `json:"chunkIndex"`

	// The chunk data
	ChunkData []byte `json:"chunkData"`
}

func (obj ProofChunk) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ClientId`:
	err = encoder.Encode(obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Serialize `Sequence`:
	err = encoder.Encode(obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Serialize `ChunkIndex`:
	err = encoder.Encode(obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Serialize `ChunkData`:
	err = encoder.Encode(obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj ProofChunk) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ProofChunk: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ProofChunk) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ClientId`:
	err = decoder.Decode(&obj.ClientId)
	if err != nil {
		return errors.NewField("ClientId", err)
	}
	// Deserialize `Sequence`:
	err = decoder.Decode(&obj.Sequence)
	if err != nil {
		return errors.NewField("Sequence", err)
	}
	// Deserialize `ChunkIndex`:
	err = decoder.Decode(&obj.ChunkIndex)
	if err != nil {
		return errors.NewField("ChunkIndex", err)
	}
	// Deserialize `ChunkData`:
	err = decoder.Decode(&obj.ChunkData)
	if err != nil {
		return errors.NewField("ChunkData", err)
	}
	return nil
}

func (obj *ProofChunk) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProofChunk: %w", err)
	}
	return nil
}

func UnmarshalProofChunk(buf []byte) (*ProofChunk, error) {
	obj := new(ProofChunk)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Proof metadata for chunked operations
type ProofMetadata struct {
	Height      uint64 `json:"height"`
	TotalChunks uint8  `json:"totalChunks"`
}

func (obj ProofMetadata) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Height`:
	err = encoder.Encode(obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Serialize `TotalChunks`:
	err = encoder.Encode(obj.TotalChunks)
	if err != nil {
		return errors.NewField("TotalChunks", err)
	}
	return nil
}

func (obj ProofMetadata) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ProofMetadata: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ProofMetadata) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Height`:
	err = decoder.Decode(&obj.Height)
	if err != nil {
		return errors.NewField("Height", err)
	}
	// Deserialize `TotalChunks`:
	err = decoder.Decode(&obj.TotalChunks)
	if err != nil {
		return errors.NewField("TotalChunks", err)
	}
	return nil
}

func (obj *ProofMetadata) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProofMetadata: %w", err)
	}
	return nil
}

func UnmarshalProofMetadata(buf []byte) (*ProofMetadata, error) {
	obj := new(ProofMetadata)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Router state account
// TODO: Implement multi-router ACL
type RouterState struct {
	// Schema version for upgrades
	Version AccountVersion `json:"version"`

	// Authority that can perform restricted operations
	Authority solanago.PublicKey `json:"authority"`

	// Reserved space for future fields
	Reserved [256]uint8 `json:"reserved"`
}

func (obj RouterState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Authority`:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Serialize `Reserved`:
	err = encoder.Encode(obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj RouterState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RouterState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RouterState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return errors.NewField("Authority", err)
	}
	// Deserialize `Reserved`:
	err = decoder.Decode(&obj.Reserved)
	if err != nil {
		return errors.NewField("Reserved", err)
	}
	return nil
}

func (obj *RouterState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RouterState: %w", err)
	}
	return nil
}

func UnmarshalRouterState(buf []byte) (*RouterState, error) {
	obj := new(RouterState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
